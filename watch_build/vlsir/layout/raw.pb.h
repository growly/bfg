// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: layout/raw.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_layout_2fraw_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_layout_2fraw_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "utils.pb.h"
#include "circuit.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_layout_2fraw_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_layout_2fraw_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_layout_2fraw_2eproto;
namespace vlsir {
namespace raw {
class Abstract;
struct AbstractDefaultTypeInternal;
extern AbstractDefaultTypeInternal _Abstract_default_instance_;
class AbstractPort;
struct AbstractPortDefaultTypeInternal;
extern AbstractPortDefaultTypeInternal _AbstractPort_default_instance_;
class Cell;
struct CellDefaultTypeInternal;
extern CellDefaultTypeInternal _Cell_default_instance_;
class Instance;
struct InstanceDefaultTypeInternal;
extern InstanceDefaultTypeInternal _Instance_default_instance_;
class Layer;
struct LayerDefaultTypeInternal;
extern LayerDefaultTypeInternal _Layer_default_instance_;
class LayerShapes;
struct LayerShapesDefaultTypeInternal;
extern LayerShapesDefaultTypeInternal _LayerShapes_default_instance_;
class Layout;
struct LayoutDefaultTypeInternal;
extern LayoutDefaultTypeInternal _Layout_default_instance_;
class Library;
struct LibraryDefaultTypeInternal;
extern LibraryDefaultTypeInternal _Library_default_instance_;
class Path;
struct PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Polygon;
struct PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Rectangle;
struct RectangleDefaultTypeInternal;
extern RectangleDefaultTypeInternal _Rectangle_default_instance_;
class TextElement;
struct TextElementDefaultTypeInternal;
extern TextElementDefaultTypeInternal _TextElement_default_instance_;
}  // namespace raw
}  // namespace vlsir
PROTOBUF_NAMESPACE_OPEN
template<> ::vlsir::raw::Abstract* Arena::CreateMaybeMessage<::vlsir::raw::Abstract>(Arena*);
template<> ::vlsir::raw::AbstractPort* Arena::CreateMaybeMessage<::vlsir::raw::AbstractPort>(Arena*);
template<> ::vlsir::raw::Cell* Arena::CreateMaybeMessage<::vlsir::raw::Cell>(Arena*);
template<> ::vlsir::raw::Instance* Arena::CreateMaybeMessage<::vlsir::raw::Instance>(Arena*);
template<> ::vlsir::raw::Layer* Arena::CreateMaybeMessage<::vlsir::raw::Layer>(Arena*);
template<> ::vlsir::raw::LayerShapes* Arena::CreateMaybeMessage<::vlsir::raw::LayerShapes>(Arena*);
template<> ::vlsir::raw::Layout* Arena::CreateMaybeMessage<::vlsir::raw::Layout>(Arena*);
template<> ::vlsir::raw::Library* Arena::CreateMaybeMessage<::vlsir::raw::Library>(Arena*);
template<> ::vlsir::raw::Path* Arena::CreateMaybeMessage<::vlsir::raw::Path>(Arena*);
template<> ::vlsir::raw::Point* Arena::CreateMaybeMessage<::vlsir::raw::Point>(Arena*);
template<> ::vlsir::raw::Polygon* Arena::CreateMaybeMessage<::vlsir::raw::Polygon>(Arena*);
template<> ::vlsir::raw::Rectangle* Arena::CreateMaybeMessage<::vlsir::raw::Rectangle>(Arena*);
template<> ::vlsir::raw::TextElement* Arena::CreateMaybeMessage<::vlsir::raw::TextElement>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vlsir {
namespace raw {

enum Units : int {
  MICRO = 0,
  NANO = 1,
  ANGSTROM = 2,
  Units_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Units_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Units_IsValid(int value);
constexpr Units Units_MIN = MICRO;
constexpr Units Units_MAX = ANGSTROM;
constexpr int Units_ARRAYSIZE = Units_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Units_descriptor();
template<typename T>
inline const std::string& Units_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Units>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Units_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Units_descriptor(), enum_t_value);
}
inline bool Units_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Units* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Units>(
    Units_descriptor(), name, value);
}
// ===================================================================

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit PROTOBUF_CONSTEXPR Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point& from) {
    Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int64 x = 1;
  void clear_x();
  int64_t x() const;
  void set_x(int64_t value);
  private:
  int64_t _internal_x() const;
  void _internal_set_x(int64_t value);
  public:

  // int64 y = 2;
  void clear_y();
  int64_t y() const;
  void set_y(int64_t value);
  private:
  int64_t _internal_y() const;
  void _internal_set_y(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t x_;
    int64_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_layout_2fraw_2eproto;
};
// -------------------------------------------------------------------

class Layer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Layer) */ {
 public:
  inline Layer() : Layer(nullptr) {}
  ~Layer() override;
  explicit PROTOBUF_CONSTEXPR Layer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Layer(const Layer& from);
  Layer(Layer&& from) noexcept
    : Layer() {
    *this = ::std::move(from);
  }

  inline Layer& operator=(const Layer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Layer& operator=(Layer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Layer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Layer* internal_default_instance() {
    return reinterpret_cast<const Layer*>(
               &_Layer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Layer& a, Layer& b) {
    a.Swap(&b);
  }
  inline void Swap(Layer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Layer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Layer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Layer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Layer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Layer& from) {
    Layer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Layer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Layer";
  }
  protected:
  explicit Layer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
    kPurposeFieldNumber = 2,
  };
  // int64 number = 1;
  void clear_number();
  int64_t number() const;
  void set_number(int64_t value);
  private:
  int64_t _internal_number() const;
  void _internal_set_number(int64_t value);
  public:

  // int64 purpose = 2;
  void clear_purpose();
  int64_t purpose() const;
  void set_purpose(int64_t value);
  private:
  int64_t _internal_purpose() const;
  void _internal_set_purpose(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Layer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t number_;
    int64_t purpose_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_layout_2fraw_2eproto;
};
// -------------------------------------------------------------------

class Rectangle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Rectangle) */ {
 public:
  inline Rectangle() : Rectangle(nullptr) {}
  ~Rectangle() override;
  explicit PROTOBUF_CONSTEXPR Rectangle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rectangle(const Rectangle& from);
  Rectangle(Rectangle&& from) noexcept
    : Rectangle() {
    *this = ::std::move(from);
  }

  inline Rectangle& operator=(const Rectangle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rectangle& operator=(Rectangle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rectangle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rectangle* internal_default_instance() {
    return reinterpret_cast<const Rectangle*>(
               &_Rectangle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Rectangle& a, Rectangle& b) {
    a.Swap(&b);
  }
  inline void Swap(Rectangle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rectangle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rectangle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rectangle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rectangle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rectangle& from) {
    Rectangle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rectangle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Rectangle";
  }
  protected:
  explicit Rectangle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetFieldNumber = 1,
    kLowerLeftFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // string net = 1;
  void clear_net();
  const std::string& net() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_net(ArgT0&& arg0, ArgT... args);
  std::string* mutable_net();
  PROTOBUF_NODISCARD std::string* release_net();
  void set_allocated_net(std::string* net);
  private:
  const std::string& _internal_net() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_net(const std::string& value);
  std::string* _internal_mutable_net();
  public:

  // .vlsir.raw.Point lower_left = 2;
  bool has_lower_left() const;
  private:
  bool _internal_has_lower_left() const;
  public:
  void clear_lower_left();
  const ::vlsir::raw::Point& lower_left() const;
  PROTOBUF_NODISCARD ::vlsir::raw::Point* release_lower_left();
  ::vlsir::raw::Point* mutable_lower_left();
  void set_allocated_lower_left(::vlsir::raw::Point* lower_left);
  private:
  const ::vlsir::raw::Point& _internal_lower_left() const;
  ::vlsir::raw::Point* _internal_mutable_lower_left();
  public:
  void unsafe_arena_set_allocated_lower_left(
      ::vlsir::raw::Point* lower_left);
  ::vlsir::raw::Point* unsafe_arena_release_lower_left();

  // int64 width = 3;
  void clear_width();
  int64_t width() const;
  void set_width(int64_t value);
  private:
  int64_t _internal_width() const;
  void _internal_set_width(int64_t value);
  public:

  // int64 height = 4;
  void clear_height();
  int64_t height() const;
  void set_height(int64_t value);
  private:
  int64_t _internal_height() const;
  void _internal_set_height(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Rectangle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr net_;
    ::vlsir::raw::Point* lower_left_;
    int64_t width_;
    int64_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_layout_2fraw_2eproto;
};
// -------------------------------------------------------------------

class Polygon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Polygon) */ {
 public:
  inline Polygon() : Polygon(nullptr) {}
  ~Polygon() override;
  explicit PROTOBUF_CONSTEXPR Polygon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Polygon(const Polygon& from);
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polygon& operator=(Polygon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Polygon& default_instance() {
    return *internal_default_instance();
  }
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }
  inline void Swap(Polygon* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Polygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Polygon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Polygon& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Polygon& from) {
    Polygon::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Polygon";
  }
  protected:
  explicit Polygon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 2,
    kNetFieldNumber = 1,
  };
  // repeated .vlsir.raw.Point vertices = 2;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::vlsir::raw::Point* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >*
      mutable_vertices();
  private:
  const ::vlsir::raw::Point& _internal_vertices(int index) const;
  ::vlsir::raw::Point* _internal_add_vertices();
  public:
  const ::vlsir::raw::Point& vertices(int index) const;
  ::vlsir::raw::Point* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >&
      vertices() const;

  // string net = 1;
  void clear_net();
  const std::string& net() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_net(ArgT0&& arg0, ArgT... args);
  std::string* mutable_net();
  PROTOBUF_NODISCARD std::string* release_net();
  void set_allocated_net(std::string* net);
  private:
  const std::string& _internal_net() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_net(const std::string& value);
  std::string* _internal_mutable_net();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Polygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point > vertices_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr net_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_layout_2fraw_2eproto;
};
// -------------------------------------------------------------------

class Path final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Path) */ {
 public:
  inline Path() : Path(nullptr) {}
  ~Path() override;
  explicit PROTOBUF_CONSTEXPR Path(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Path(const Path& from);
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path& operator=(Path&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Path& default_instance() {
    return *internal_default_instance();
  }
  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Path* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Path& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Path& from) {
    Path::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Path";
  }
  protected:
  explicit Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kNetFieldNumber = 1,
    kWidthFieldNumber = 3,
  };
  // repeated .vlsir.raw.Point points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::vlsir::raw::Point* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >*
      mutable_points();
  private:
  const ::vlsir::raw::Point& _internal_points(int index) const;
  ::vlsir::raw::Point* _internal_add_points();
  public:
  const ::vlsir::raw::Point& points(int index) const;
  ::vlsir::raw::Point* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >&
      points() const;

  // string net = 1;
  void clear_net();
  const std::string& net() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_net(ArgT0&& arg0, ArgT... args);
  std::string* mutable_net();
  PROTOBUF_NODISCARD std::string* release_net();
  void set_allocated_net(std::string* net);
  private:
  const std::string& _internal_net() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_net(const std::string& value);
  std::string* _internal_mutable_net();
  public:

  // int64 width = 3;
  void clear_width();
  int64_t width() const;
  void set_width(int64_t value);
  private:
  int64_t _internal_width() const;
  void _internal_set_width(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point > points_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr net_;
    int64_t width_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_layout_2fraw_2eproto;
};
// -------------------------------------------------------------------

class LayerShapes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.LayerShapes) */ {
 public:
  inline LayerShapes() : LayerShapes(nullptr) {}
  ~LayerShapes() override;
  explicit PROTOBUF_CONSTEXPR LayerShapes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LayerShapes(const LayerShapes& from);
  LayerShapes(LayerShapes&& from) noexcept
    : LayerShapes() {
    *this = ::std::move(from);
  }

  inline LayerShapes& operator=(const LayerShapes& from) {
    CopyFrom(from);
    return *this;
  }
  inline LayerShapes& operator=(LayerShapes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LayerShapes& default_instance() {
    return *internal_default_instance();
  }
  static inline const LayerShapes* internal_default_instance() {
    return reinterpret_cast<const LayerShapes*>(
               &_LayerShapes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LayerShapes& a, LayerShapes& b) {
    a.Swap(&b);
  }
  inline void Swap(LayerShapes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LayerShapes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LayerShapes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LayerShapes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LayerShapes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LayerShapes& from) {
    LayerShapes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LayerShapes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.LayerShapes";
  }
  protected:
  explicit LayerShapes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRectanglesFieldNumber = 2,
    kPolygonsFieldNumber = 3,
    kPathsFieldNumber = 4,
    kLayerFieldNumber = 1,
  };
  // repeated .vlsir.raw.Rectangle rectangles = 2;
  int rectangles_size() const;
  private:
  int _internal_rectangles_size() const;
  public:
  void clear_rectangles();
  ::vlsir::raw::Rectangle* mutable_rectangles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Rectangle >*
      mutable_rectangles();
  private:
  const ::vlsir::raw::Rectangle& _internal_rectangles(int index) const;
  ::vlsir::raw::Rectangle* _internal_add_rectangles();
  public:
  const ::vlsir::raw::Rectangle& rectangles(int index) const;
  ::vlsir::raw::Rectangle* add_rectangles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Rectangle >&
      rectangles() const;

  // repeated .vlsir.raw.Polygon polygons = 3;
  int polygons_size() const;
  private:
  int _internal_polygons_size() const;
  public:
  void clear_polygons();
  ::vlsir::raw::Polygon* mutable_polygons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Polygon >*
      mutable_polygons();
  private:
  const ::vlsir::raw::Polygon& _internal_polygons(int index) const;
  ::vlsir::raw::Polygon* _internal_add_polygons();
  public:
  const ::vlsir::raw::Polygon& polygons(int index) const;
  ::vlsir::raw::Polygon* add_polygons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Polygon >&
      polygons() const;

  // repeated .vlsir.raw.Path paths = 4;
  int paths_size() const;
  private:
  int _internal_paths_size() const;
  public:
  void clear_paths();
  ::vlsir::raw::Path* mutable_paths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Path >*
      mutable_paths();
  private:
  const ::vlsir::raw::Path& _internal_paths(int index) const;
  ::vlsir::raw::Path* _internal_add_paths();
  public:
  const ::vlsir::raw::Path& paths(int index) const;
  ::vlsir::raw::Path* add_paths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Path >&
      paths() const;

  // .vlsir.raw.Layer layer = 1;
  bool has_layer() const;
  private:
  bool _internal_has_layer() const;
  public:
  void clear_layer();
  const ::vlsir::raw::Layer& layer() const;
  PROTOBUF_NODISCARD ::vlsir::raw::Layer* release_layer();
  ::vlsir::raw::Layer* mutable_layer();
  void set_allocated_layer(::vlsir::raw::Layer* layer);
  private:
  const ::vlsir::raw::Layer& _internal_layer() const;
  ::vlsir::raw::Layer* _internal_mutable_layer();
  public:
  void unsafe_arena_set_allocated_layer(
      ::vlsir::raw::Layer* layer);
  ::vlsir::raw::Layer* unsafe_arena_release_layer();

  // @@protoc_insertion_point(class_scope:vlsir.raw.LayerShapes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Rectangle > rectangles_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Polygon > polygons_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Path > paths_;
    ::vlsir::raw::Layer* layer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_layout_2fraw_2eproto;
};
// -------------------------------------------------------------------

class TextElement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.TextElement) */ {
 public:
  inline TextElement() : TextElement(nullptr) {}
  ~TextElement() override;
  explicit PROTOBUF_CONSTEXPR TextElement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextElement(const TextElement& from);
  TextElement(TextElement&& from) noexcept
    : TextElement() {
    *this = ::std::move(from);
  }

  inline TextElement& operator=(const TextElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextElement& operator=(TextElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextElement* internal_default_instance() {
    return reinterpret_cast<const TextElement*>(
               &_TextElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TextElement& a, TextElement& b) {
    a.Swap(&b);
  }
  inline void Swap(TextElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextElement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextElement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextElement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextElement& from) {
    TextElement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextElement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.TextElement";
  }
  protected:
  explicit TextElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringFieldNumber = 1,
    kLocFieldNumber = 2,
  };
  // string string = 1;
  void clear_string();
  const std::string& string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string();
  PROTOBUF_NODISCARD std::string* release_string();
  void set_allocated_string(std::string* string);
  private:
  const std::string& _internal_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string(const std::string& value);
  std::string* _internal_mutable_string();
  public:

  // .vlsir.raw.Point loc = 2;
  bool has_loc() const;
  private:
  bool _internal_has_loc() const;
  public:
  void clear_loc();
  const ::vlsir::raw::Point& loc() const;
  PROTOBUF_NODISCARD ::vlsir::raw::Point* release_loc();
  ::vlsir::raw::Point* mutable_loc();
  void set_allocated_loc(::vlsir::raw::Point* loc);
  private:
  const ::vlsir::raw::Point& _internal_loc() const;
  ::vlsir::raw::Point* _internal_mutable_loc();
  public:
  void unsafe_arena_set_allocated_loc(
      ::vlsir::raw::Point* loc);
  ::vlsir::raw::Point* unsafe_arena_release_loc();

  // @@protoc_insertion_point(class_scope:vlsir.raw.TextElement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_;
    ::vlsir::raw::Point* loc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_layout_2fraw_2eproto;
};
// -------------------------------------------------------------------

class Instance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Instance) */ {
 public:
  inline Instance() : Instance(nullptr) {}
  ~Instance() override;
  explicit PROTOBUF_CONSTEXPR Instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Instance(const Instance& from);
  Instance(Instance&& from) noexcept
    : Instance() {
    *this = ::std::move(from);
  }

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Instance& operator=(Instance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Instance& default_instance() {
    return *internal_default_instance();
  }
  static inline const Instance* internal_default_instance() {
    return reinterpret_cast<const Instance*>(
               &_Instance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Instance& a, Instance& b) {
    a.Swap(&b);
  }
  inline void Swap(Instance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Instance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Instance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Instance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Instance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Instance& from) {
    Instance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Instance";
  }
  protected:
  explicit Instance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCellFieldNumber = 3,
    kOriginLocationFieldNumber = 4,
    kReflectVertFieldNumber = 6,
    kRotationClockwiseDegreesFieldNumber = 7,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.utils.Reference cell = 3;
  bool has_cell() const;
  private:
  bool _internal_has_cell() const;
  public:
  void clear_cell();
  const ::vlsir::utils::Reference& cell() const;
  PROTOBUF_NODISCARD ::vlsir::utils::Reference* release_cell();
  ::vlsir::utils::Reference* mutable_cell();
  void set_allocated_cell(::vlsir::utils::Reference* cell);
  private:
  const ::vlsir::utils::Reference& _internal_cell() const;
  ::vlsir::utils::Reference* _internal_mutable_cell();
  public:
  void unsafe_arena_set_allocated_cell(
      ::vlsir::utils::Reference* cell);
  ::vlsir::utils::Reference* unsafe_arena_release_cell();

  // .vlsir.raw.Point origin_location = 4;
  bool has_origin_location() const;
  private:
  bool _internal_has_origin_location() const;
  public:
  void clear_origin_location();
  const ::vlsir::raw::Point& origin_location() const;
  PROTOBUF_NODISCARD ::vlsir::raw::Point* release_origin_location();
  ::vlsir::raw::Point* mutable_origin_location();
  void set_allocated_origin_location(::vlsir::raw::Point* origin_location);
  private:
  const ::vlsir::raw::Point& _internal_origin_location() const;
  ::vlsir::raw::Point* _internal_mutable_origin_location();
  public:
  void unsafe_arena_set_allocated_origin_location(
      ::vlsir::raw::Point* origin_location);
  ::vlsir::raw::Point* unsafe_arena_release_origin_location();

  // bool reflect_vert = 6;
  void clear_reflect_vert();
  bool reflect_vert() const;
  void set_reflect_vert(bool value);
  private:
  bool _internal_reflect_vert() const;
  void _internal_set_reflect_vert(bool value);
  public:

  // int32 rotation_clockwise_degrees = 7;
  void clear_rotation_clockwise_degrees();
  int32_t rotation_clockwise_degrees() const;
  void set_rotation_clockwise_degrees(int32_t value);
  private:
  int32_t _internal_rotation_clockwise_degrees() const;
  void _internal_set_rotation_clockwise_degrees(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Instance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::vlsir::utils::Reference* cell_;
    ::vlsir::raw::Point* origin_location_;
    bool reflect_vert_;
    int32_t rotation_clockwise_degrees_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_layout_2fraw_2eproto;
};
// -------------------------------------------------------------------

class Layout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Layout) */ {
 public:
  inline Layout() : Layout(nullptr) {}
  ~Layout() override;
  explicit PROTOBUF_CONSTEXPR Layout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Layout(const Layout& from);
  Layout(Layout&& from) noexcept
    : Layout() {
    *this = ::std::move(from);
  }

  inline Layout& operator=(const Layout& from) {
    CopyFrom(from);
    return *this;
  }
  inline Layout& operator=(Layout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Layout& default_instance() {
    return *internal_default_instance();
  }
  static inline const Layout* internal_default_instance() {
    return reinterpret_cast<const Layout*>(
               &_Layout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Layout& a, Layout& b) {
    a.Swap(&b);
  }
  inline void Swap(Layout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Layout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Layout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Layout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Layout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Layout& from) {
    Layout::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Layout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Layout";
  }
  protected:
  explicit Layout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapesFieldNumber = 2,
    kInstancesFieldNumber = 3,
    kAnnotationsFieldNumber = 4,
    kNameFieldNumber = 1,
  };
  // repeated .vlsir.raw.LayerShapes shapes = 2;
  int shapes_size() const;
  private:
  int _internal_shapes_size() const;
  public:
  void clear_shapes();
  ::vlsir::raw::LayerShapes* mutable_shapes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >*
      mutable_shapes();
  private:
  const ::vlsir::raw::LayerShapes& _internal_shapes(int index) const;
  ::vlsir::raw::LayerShapes* _internal_add_shapes();
  public:
  const ::vlsir::raw::LayerShapes& shapes(int index) const;
  ::vlsir::raw::LayerShapes* add_shapes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >&
      shapes() const;

  // repeated .vlsir.raw.Instance instances = 3;
  int instances_size() const;
  private:
  int _internal_instances_size() const;
  public:
  void clear_instances();
  ::vlsir::raw::Instance* mutable_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Instance >*
      mutable_instances();
  private:
  const ::vlsir::raw::Instance& _internal_instances(int index) const;
  ::vlsir::raw::Instance* _internal_add_instances();
  public:
  const ::vlsir::raw::Instance& instances(int index) const;
  ::vlsir::raw::Instance* add_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Instance >&
      instances() const;

  // repeated .vlsir.raw.TextElement annotations = 4;
  int annotations_size() const;
  private:
  int _internal_annotations_size() const;
  public:
  void clear_annotations();
  ::vlsir::raw::TextElement* mutable_annotations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::TextElement >*
      mutable_annotations();
  private:
  const ::vlsir::raw::TextElement& _internal_annotations(int index) const;
  ::vlsir::raw::TextElement* _internal_add_annotations();
  public:
  const ::vlsir::raw::TextElement& annotations(int index) const;
  ::vlsir::raw::TextElement* add_annotations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::TextElement >&
      annotations() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Layout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes > shapes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Instance > instances_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::TextElement > annotations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_layout_2fraw_2eproto;
};
// -------------------------------------------------------------------

class Abstract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Abstract) */ {
 public:
  inline Abstract() : Abstract(nullptr) {}
  ~Abstract() override;
  explicit PROTOBUF_CONSTEXPR Abstract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Abstract(const Abstract& from);
  Abstract(Abstract&& from) noexcept
    : Abstract() {
    *this = ::std::move(from);
  }

  inline Abstract& operator=(const Abstract& from) {
    CopyFrom(from);
    return *this;
  }
  inline Abstract& operator=(Abstract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Abstract& default_instance() {
    return *internal_default_instance();
  }
  static inline const Abstract* internal_default_instance() {
    return reinterpret_cast<const Abstract*>(
               &_Abstract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Abstract& a, Abstract& b) {
    a.Swap(&b);
  }
  inline void Swap(Abstract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Abstract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Abstract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Abstract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Abstract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Abstract& from) {
    Abstract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Abstract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Abstract";
  }
  protected:
  explicit Abstract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortsFieldNumber = 4,
    kBlockagesFieldNumber = 5,
    kNameFieldNumber = 1,
    kOutlineFieldNumber = 2,
  };
  // repeated .vlsir.raw.AbstractPort ports = 4;
  int ports_size() const;
  private:
  int _internal_ports_size() const;
  public:
  void clear_ports();
  ::vlsir::raw::AbstractPort* mutable_ports(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::AbstractPort >*
      mutable_ports();
  private:
  const ::vlsir::raw::AbstractPort& _internal_ports(int index) const;
  ::vlsir::raw::AbstractPort* _internal_add_ports();
  public:
  const ::vlsir::raw::AbstractPort& ports(int index) const;
  ::vlsir::raw::AbstractPort* add_ports();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::AbstractPort >&
      ports() const;

  // repeated .vlsir.raw.LayerShapes blockages = 5;
  int blockages_size() const;
  private:
  int _internal_blockages_size() const;
  public:
  void clear_blockages();
  ::vlsir::raw::LayerShapes* mutable_blockages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >*
      mutable_blockages();
  private:
  const ::vlsir::raw::LayerShapes& _internal_blockages(int index) const;
  ::vlsir::raw::LayerShapes* _internal_add_blockages();
  public:
  const ::vlsir::raw::LayerShapes& blockages(int index) const;
  ::vlsir::raw::LayerShapes* add_blockages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >&
      blockages() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.raw.Polygon outline = 2;
  bool has_outline() const;
  private:
  bool _internal_has_outline() const;
  public:
  void clear_outline();
  const ::vlsir::raw::Polygon& outline() const;
  PROTOBUF_NODISCARD ::vlsir::raw::Polygon* release_outline();
  ::vlsir::raw::Polygon* mutable_outline();
  void set_allocated_outline(::vlsir::raw::Polygon* outline);
  private:
  const ::vlsir::raw::Polygon& _internal_outline() const;
  ::vlsir::raw::Polygon* _internal_mutable_outline();
  public:
  void unsafe_arena_set_allocated_outline(
      ::vlsir::raw::Polygon* outline);
  ::vlsir::raw::Polygon* unsafe_arena_release_outline();

  // @@protoc_insertion_point(class_scope:vlsir.raw.Abstract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::AbstractPort > ports_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes > blockages_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::vlsir::raw::Polygon* outline_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_layout_2fraw_2eproto;
};
// -------------------------------------------------------------------

class AbstractPort final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.AbstractPort) */ {
 public:
  inline AbstractPort() : AbstractPort(nullptr) {}
  ~AbstractPort() override;
  explicit PROTOBUF_CONSTEXPR AbstractPort(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AbstractPort(const AbstractPort& from);
  AbstractPort(AbstractPort&& from) noexcept
    : AbstractPort() {
    *this = ::std::move(from);
  }

  inline AbstractPort& operator=(const AbstractPort& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbstractPort& operator=(AbstractPort&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbstractPort& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbstractPort* internal_default_instance() {
    return reinterpret_cast<const AbstractPort*>(
               &_AbstractPort_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AbstractPort& a, AbstractPort& b) {
    a.Swap(&b);
  }
  inline void Swap(AbstractPort* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbstractPort* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbstractPort* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AbstractPort>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AbstractPort& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AbstractPort& from) {
    AbstractPort::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbstractPort* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.AbstractPort";
  }
  protected:
  explicit AbstractPort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapesFieldNumber = 2,
    kNetFieldNumber = 1,
  };
  // repeated .vlsir.raw.LayerShapes shapes = 2;
  int shapes_size() const;
  private:
  int _internal_shapes_size() const;
  public:
  void clear_shapes();
  ::vlsir::raw::LayerShapes* mutable_shapes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >*
      mutable_shapes();
  private:
  const ::vlsir::raw::LayerShapes& _internal_shapes(int index) const;
  ::vlsir::raw::LayerShapes* _internal_add_shapes();
  public:
  const ::vlsir::raw::LayerShapes& shapes(int index) const;
  ::vlsir::raw::LayerShapes* add_shapes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >&
      shapes() const;

  // string net = 1;
  void clear_net();
  const std::string& net() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_net(ArgT0&& arg0, ArgT... args);
  std::string* mutable_net();
  PROTOBUF_NODISCARD std::string* release_net();
  void set_allocated_net(std::string* net);
  private:
  const std::string& _internal_net() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_net(const std::string& value);
  std::string* _internal_mutable_net();
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.AbstractPort)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes > shapes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr net_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_layout_2fraw_2eproto;
};
// -------------------------------------------------------------------

class Cell final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Cell) */ {
 public:
  inline Cell() : Cell(nullptr) {}
  ~Cell() override;
  explicit PROTOBUF_CONSTEXPR Cell(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cell(const Cell& from);
  Cell(Cell&& from) noexcept
    : Cell() {
    *this = ::std::move(from);
  }

  inline Cell& operator=(const Cell& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cell& operator=(Cell&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cell& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cell* internal_default_instance() {
    return reinterpret_cast<const Cell*>(
               &_Cell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Cell& a, Cell& b) {
    a.Swap(&b);
  }
  inline void Swap(Cell* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cell* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Cell* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Cell>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Cell& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Cell& from) {
    Cell::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cell* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Cell";
  }
  protected:
  explicit Cell(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kInterfaceFieldNumber = 10,
    kModuleFieldNumber = 11,
    kAbstractFieldNumber = 12,
    kLayoutFieldNumber = 13,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vlsir.circuit.Interface interface = 10;
  bool has_interface() const;
  private:
  bool _internal_has_interface() const;
  public:
  void clear_interface();
  const ::vlsir::circuit::Interface& interface() const;
  PROTOBUF_NODISCARD ::vlsir::circuit::Interface* release_interface();
  ::vlsir::circuit::Interface* mutable_interface();
  void set_allocated_interface(::vlsir::circuit::Interface* interface);
  private:
  const ::vlsir::circuit::Interface& _internal_interface() const;
  ::vlsir::circuit::Interface* _internal_mutable_interface();
  public:
  void unsafe_arena_set_allocated_interface(
      ::vlsir::circuit::Interface* interface);
  ::vlsir::circuit::Interface* unsafe_arena_release_interface();

  // .vlsir.circuit.Module module = 11;
  bool has_module() const;
  private:
  bool _internal_has_module() const;
  public:
  void clear_module();
  const ::vlsir::circuit::Module& module() const;
  PROTOBUF_NODISCARD ::vlsir::circuit::Module* release_module();
  ::vlsir::circuit::Module* mutable_module();
  void set_allocated_module(::vlsir::circuit::Module* module);
  private:
  const ::vlsir::circuit::Module& _internal_module() const;
  ::vlsir::circuit::Module* _internal_mutable_module();
  public:
  void unsafe_arena_set_allocated_module(
      ::vlsir::circuit::Module* module);
  ::vlsir::circuit::Module* unsafe_arena_release_module();

  // .vlsir.raw.Abstract abstract = 12;
  bool has_abstract() const;
  private:
  bool _internal_has_abstract() const;
  public:
  void clear_abstract();
  const ::vlsir::raw::Abstract& abstract() const;
  PROTOBUF_NODISCARD ::vlsir::raw::Abstract* release_abstract();
  ::vlsir::raw::Abstract* mutable_abstract();
  void set_allocated_abstract(::vlsir::raw::Abstract* abstract);
  private:
  const ::vlsir::raw::Abstract& _internal_abstract() const;
  ::vlsir::raw::Abstract* _internal_mutable_abstract();
  public:
  void unsafe_arena_set_allocated_abstract(
      ::vlsir::raw::Abstract* abstract);
  ::vlsir::raw::Abstract* unsafe_arena_release_abstract();

  // .vlsir.raw.Layout layout = 13;
  bool has_layout() const;
  private:
  bool _internal_has_layout() const;
  public:
  void clear_layout();
  const ::vlsir::raw::Layout& layout() const;
  PROTOBUF_NODISCARD ::vlsir::raw::Layout* release_layout();
  ::vlsir::raw::Layout* mutable_layout();
  void set_allocated_layout(::vlsir::raw::Layout* layout);
  private:
  const ::vlsir::raw::Layout& _internal_layout() const;
  ::vlsir::raw::Layout* _internal_mutable_layout();
  public:
  void unsafe_arena_set_allocated_layout(
      ::vlsir::raw::Layout* layout);
  ::vlsir::raw::Layout* unsafe_arena_release_layout();

  // @@protoc_insertion_point(class_scope:vlsir.raw.Cell)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::vlsir::circuit::Interface* interface_;
    ::vlsir::circuit::Module* module_;
    ::vlsir::raw::Abstract* abstract_;
    ::vlsir::raw::Layout* layout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_layout_2fraw_2eproto;
};
// -------------------------------------------------------------------

class Library final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vlsir.raw.Library) */ {
 public:
  inline Library() : Library(nullptr) {}
  ~Library() override;
  explicit PROTOBUF_CONSTEXPR Library(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Library(const Library& from);
  Library(Library&& from) noexcept
    : Library() {
    *this = ::std::move(from);
  }

  inline Library& operator=(const Library& from) {
    CopyFrom(from);
    return *this;
  }
  inline Library& operator=(Library&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Library& default_instance() {
    return *internal_default_instance();
  }
  static inline const Library* internal_default_instance() {
    return reinterpret_cast<const Library*>(
               &_Library_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Library& a, Library& b) {
    a.Swap(&b);
  }
  inline void Swap(Library* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Library* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Library* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Library>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Library& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Library& from) {
    Library::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Library* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vlsir.raw.Library";
  }
  protected:
  explicit Library(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellsFieldNumber = 10,
    kDomainFieldNumber = 1,
    kAuthorFieldNumber = 20,
    kUnitsFieldNumber = 2,
  };
  // repeated .vlsir.raw.Cell cells = 10;
  int cells_size() const;
  private:
  int _internal_cells_size() const;
  public:
  void clear_cells();
  ::vlsir::raw::Cell* mutable_cells(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Cell >*
      mutable_cells();
  private:
  const ::vlsir::raw::Cell& _internal_cells(int index) const;
  ::vlsir::raw::Cell* _internal_add_cells();
  public:
  const ::vlsir::raw::Cell& cells(int index) const;
  ::vlsir::raw::Cell* add_cells();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Cell >&
      cells() const;

  // string domain = 1;
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // .vlsir.utils.AuthorMetadata author = 20;
  bool has_author() const;
  private:
  bool _internal_has_author() const;
  public:
  void clear_author();
  const ::vlsir::utils::AuthorMetadata& author() const;
  PROTOBUF_NODISCARD ::vlsir::utils::AuthorMetadata* release_author();
  ::vlsir::utils::AuthorMetadata* mutable_author();
  void set_allocated_author(::vlsir::utils::AuthorMetadata* author);
  private:
  const ::vlsir::utils::AuthorMetadata& _internal_author() const;
  ::vlsir::utils::AuthorMetadata* _internal_mutable_author();
  public:
  void unsafe_arena_set_allocated_author(
      ::vlsir::utils::AuthorMetadata* author);
  ::vlsir::utils::AuthorMetadata* unsafe_arena_release_author();

  // .vlsir.raw.Units units = 2;
  void clear_units();
  ::vlsir::raw::Units units() const;
  void set_units(::vlsir::raw::Units value);
  private:
  ::vlsir::raw::Units _internal_units() const;
  void _internal_set_units(::vlsir::raw::Units value);
  public:

  // @@protoc_insertion_point(class_scope:vlsir.raw.Library)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Cell > cells_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
    ::vlsir::utils::AuthorMetadata* author_;
    int units_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_layout_2fraw_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point

// int64 x = 1;
inline void Point::clear_x() {
  _impl_.x_ = int64_t{0};
}
inline int64_t Point::_internal_x() const {
  return _impl_.x_;
}
inline int64_t Point::x() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Point.x)
  return _internal_x();
}
inline void Point::_internal_set_x(int64_t value) {
  
  _impl_.x_ = value;
}
inline void Point::set_x(int64_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Point.x)
}

// int64 y = 2;
inline void Point::clear_y() {
  _impl_.y_ = int64_t{0};
}
inline int64_t Point::_internal_y() const {
  return _impl_.y_;
}
inline int64_t Point::y() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Point.y)
  return _internal_y();
}
inline void Point::_internal_set_y(int64_t value) {
  
  _impl_.y_ = value;
}
inline void Point::set_y(int64_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Point.y)
}

// -------------------------------------------------------------------

// Layer

// int64 number = 1;
inline void Layer::clear_number() {
  _impl_.number_ = int64_t{0};
}
inline int64_t Layer::_internal_number() const {
  return _impl_.number_;
}
inline int64_t Layer::number() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Layer.number)
  return _internal_number();
}
inline void Layer::_internal_set_number(int64_t value) {
  
  _impl_.number_ = value;
}
inline void Layer::set_number(int64_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Layer.number)
}

// int64 purpose = 2;
inline void Layer::clear_purpose() {
  _impl_.purpose_ = int64_t{0};
}
inline int64_t Layer::_internal_purpose() const {
  return _impl_.purpose_;
}
inline int64_t Layer::purpose() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Layer.purpose)
  return _internal_purpose();
}
inline void Layer::_internal_set_purpose(int64_t value) {
  
  _impl_.purpose_ = value;
}
inline void Layer::set_purpose(int64_t value) {
  _internal_set_purpose(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Layer.purpose)
}

// -------------------------------------------------------------------

// Rectangle

// string net = 1;
inline void Rectangle::clear_net() {
  _impl_.net_.ClearToEmpty();
}
inline const std::string& Rectangle::net() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Rectangle.net)
  return _internal_net();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Rectangle::set_net(ArgT0&& arg0, ArgT... args) {
 
 _impl_.net_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.raw.Rectangle.net)
}
inline std::string* Rectangle::mutable_net() {
  std::string* _s = _internal_mutable_net();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Rectangle.net)
  return _s;
}
inline const std::string& Rectangle::_internal_net() const {
  return _impl_.net_.Get();
}
inline void Rectangle::_internal_set_net(const std::string& value) {
  
  _impl_.net_.Set(value, GetArenaForAllocation());
}
inline std::string* Rectangle::_internal_mutable_net() {
  
  return _impl_.net_.Mutable(GetArenaForAllocation());
}
inline std::string* Rectangle::release_net() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Rectangle.net)
  return _impl_.net_.Release();
}
inline void Rectangle::set_allocated_net(std::string* net) {
  if (net != nullptr) {
    
  } else {
    
  }
  _impl_.net_.SetAllocated(net, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.net_.IsDefault()) {
    _impl_.net_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Rectangle.net)
}

// .vlsir.raw.Point lower_left = 2;
inline bool Rectangle::_internal_has_lower_left() const {
  return this != internal_default_instance() && _impl_.lower_left_ != nullptr;
}
inline bool Rectangle::has_lower_left() const {
  return _internal_has_lower_left();
}
inline void Rectangle::clear_lower_left() {
  if (GetArenaForAllocation() == nullptr && _impl_.lower_left_ != nullptr) {
    delete _impl_.lower_left_;
  }
  _impl_.lower_left_ = nullptr;
}
inline const ::vlsir::raw::Point& Rectangle::_internal_lower_left() const {
  const ::vlsir::raw::Point* p = _impl_.lower_left_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::raw::Point&>(
      ::vlsir::raw::_Point_default_instance_);
}
inline const ::vlsir::raw::Point& Rectangle::lower_left() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Rectangle.lower_left)
  return _internal_lower_left();
}
inline void Rectangle::unsafe_arena_set_allocated_lower_left(
    ::vlsir::raw::Point* lower_left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lower_left_);
  }
  _impl_.lower_left_ = lower_left;
  if (lower_left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Rectangle.lower_left)
}
inline ::vlsir::raw::Point* Rectangle::release_lower_left() {
  
  ::vlsir::raw::Point* temp = _impl_.lower_left_;
  _impl_.lower_left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::raw::Point* Rectangle::unsafe_arena_release_lower_left() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Rectangle.lower_left)
  
  ::vlsir::raw::Point* temp = _impl_.lower_left_;
  _impl_.lower_left_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Point* Rectangle::_internal_mutable_lower_left() {
  
  if (_impl_.lower_left_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Point>(GetArenaForAllocation());
    _impl_.lower_left_ = p;
  }
  return _impl_.lower_left_;
}
inline ::vlsir::raw::Point* Rectangle::mutable_lower_left() {
  ::vlsir::raw::Point* _msg = _internal_mutable_lower_left();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Rectangle.lower_left)
  return _msg;
}
inline void Rectangle::set_allocated_lower_left(::vlsir::raw::Point* lower_left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lower_left_;
  }
  if (lower_left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lower_left);
    if (message_arena != submessage_arena) {
      lower_left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lower_left, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lower_left_ = lower_left;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Rectangle.lower_left)
}

// int64 width = 3;
inline void Rectangle::clear_width() {
  _impl_.width_ = int64_t{0};
}
inline int64_t Rectangle::_internal_width() const {
  return _impl_.width_;
}
inline int64_t Rectangle::width() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Rectangle.width)
  return _internal_width();
}
inline void Rectangle::_internal_set_width(int64_t value) {
  
  _impl_.width_ = value;
}
inline void Rectangle::set_width(int64_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Rectangle.width)
}

// int64 height = 4;
inline void Rectangle::clear_height() {
  _impl_.height_ = int64_t{0};
}
inline int64_t Rectangle::_internal_height() const {
  return _impl_.height_;
}
inline int64_t Rectangle::height() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Rectangle.height)
  return _internal_height();
}
inline void Rectangle::_internal_set_height(int64_t value) {
  
  _impl_.height_ = value;
}
inline void Rectangle::set_height(int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Rectangle.height)
}

// -------------------------------------------------------------------

// Polygon

// string net = 1;
inline void Polygon::clear_net() {
  _impl_.net_.ClearToEmpty();
}
inline const std::string& Polygon::net() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Polygon.net)
  return _internal_net();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Polygon::set_net(ArgT0&& arg0, ArgT... args) {
 
 _impl_.net_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.raw.Polygon.net)
}
inline std::string* Polygon::mutable_net() {
  std::string* _s = _internal_mutable_net();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Polygon.net)
  return _s;
}
inline const std::string& Polygon::_internal_net() const {
  return _impl_.net_.Get();
}
inline void Polygon::_internal_set_net(const std::string& value) {
  
  _impl_.net_.Set(value, GetArenaForAllocation());
}
inline std::string* Polygon::_internal_mutable_net() {
  
  return _impl_.net_.Mutable(GetArenaForAllocation());
}
inline std::string* Polygon::release_net() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Polygon.net)
  return _impl_.net_.Release();
}
inline void Polygon::set_allocated_net(std::string* net) {
  if (net != nullptr) {
    
  } else {
    
  }
  _impl_.net_.SetAllocated(net, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.net_.IsDefault()) {
    _impl_.net_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Polygon.net)
}

// repeated .vlsir.raw.Point vertices = 2;
inline int Polygon::_internal_vertices_size() const {
  return _impl_.vertices_.size();
}
inline int Polygon::vertices_size() const {
  return _internal_vertices_size();
}
inline void Polygon::clear_vertices() {
  _impl_.vertices_.Clear();
}
inline ::vlsir::raw::Point* Polygon::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Polygon.vertices)
  return _impl_.vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >*
Polygon::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Polygon.vertices)
  return &_impl_.vertices_;
}
inline const ::vlsir::raw::Point& Polygon::_internal_vertices(int index) const {
  return _impl_.vertices_.Get(index);
}
inline const ::vlsir::raw::Point& Polygon::vertices(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Polygon.vertices)
  return _internal_vertices(index);
}
inline ::vlsir::raw::Point* Polygon::_internal_add_vertices() {
  return _impl_.vertices_.Add();
}
inline ::vlsir::raw::Point* Polygon::add_vertices() {
  ::vlsir::raw::Point* _add = _internal_add_vertices();
  // @@protoc_insertion_point(field_add:vlsir.raw.Polygon.vertices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >&
Polygon::vertices() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Polygon.vertices)
  return _impl_.vertices_;
}

// -------------------------------------------------------------------

// Path

// string net = 1;
inline void Path::clear_net() {
  _impl_.net_.ClearToEmpty();
}
inline const std::string& Path::net() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Path.net)
  return _internal_net();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Path::set_net(ArgT0&& arg0, ArgT... args) {
 
 _impl_.net_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.raw.Path.net)
}
inline std::string* Path::mutable_net() {
  std::string* _s = _internal_mutable_net();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Path.net)
  return _s;
}
inline const std::string& Path::_internal_net() const {
  return _impl_.net_.Get();
}
inline void Path::_internal_set_net(const std::string& value) {
  
  _impl_.net_.Set(value, GetArenaForAllocation());
}
inline std::string* Path::_internal_mutable_net() {
  
  return _impl_.net_.Mutable(GetArenaForAllocation());
}
inline std::string* Path::release_net() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Path.net)
  return _impl_.net_.Release();
}
inline void Path::set_allocated_net(std::string* net) {
  if (net != nullptr) {
    
  } else {
    
  }
  _impl_.net_.SetAllocated(net, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.net_.IsDefault()) {
    _impl_.net_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Path.net)
}

// repeated .vlsir.raw.Point points = 2;
inline int Path::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int Path::points_size() const {
  return _internal_points_size();
}
inline void Path::clear_points() {
  _impl_.points_.Clear();
}
inline ::vlsir::raw::Point* Path::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Path.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >*
Path::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Path.points)
  return &_impl_.points_;
}
inline const ::vlsir::raw::Point& Path::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::vlsir::raw::Point& Path::points(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Path.points)
  return _internal_points(index);
}
inline ::vlsir::raw::Point* Path::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::vlsir::raw::Point* Path::add_points() {
  ::vlsir::raw::Point* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:vlsir.raw.Path.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Point >&
Path::points() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Path.points)
  return _impl_.points_;
}

// int64 width = 3;
inline void Path::clear_width() {
  _impl_.width_ = int64_t{0};
}
inline int64_t Path::_internal_width() const {
  return _impl_.width_;
}
inline int64_t Path::width() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Path.width)
  return _internal_width();
}
inline void Path::_internal_set_width(int64_t value) {
  
  _impl_.width_ = value;
}
inline void Path::set_width(int64_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Path.width)
}

// -------------------------------------------------------------------

// LayerShapes

// .vlsir.raw.Layer layer = 1;
inline bool LayerShapes::_internal_has_layer() const {
  return this != internal_default_instance() && _impl_.layer_ != nullptr;
}
inline bool LayerShapes::has_layer() const {
  return _internal_has_layer();
}
inline void LayerShapes::clear_layer() {
  if (GetArenaForAllocation() == nullptr && _impl_.layer_ != nullptr) {
    delete _impl_.layer_;
  }
  _impl_.layer_ = nullptr;
}
inline const ::vlsir::raw::Layer& LayerShapes::_internal_layer() const {
  const ::vlsir::raw::Layer* p = _impl_.layer_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::raw::Layer&>(
      ::vlsir::raw::_Layer_default_instance_);
}
inline const ::vlsir::raw::Layer& LayerShapes::layer() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.LayerShapes.layer)
  return _internal_layer();
}
inline void LayerShapes::unsafe_arena_set_allocated_layer(
    ::vlsir::raw::Layer* layer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.layer_);
  }
  _impl_.layer_ = layer;
  if (layer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.LayerShapes.layer)
}
inline ::vlsir::raw::Layer* LayerShapes::release_layer() {
  
  ::vlsir::raw::Layer* temp = _impl_.layer_;
  _impl_.layer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::raw::Layer* LayerShapes::unsafe_arena_release_layer() {
  // @@protoc_insertion_point(field_release:vlsir.raw.LayerShapes.layer)
  
  ::vlsir::raw::Layer* temp = _impl_.layer_;
  _impl_.layer_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Layer* LayerShapes::_internal_mutable_layer() {
  
  if (_impl_.layer_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Layer>(GetArenaForAllocation());
    _impl_.layer_ = p;
  }
  return _impl_.layer_;
}
inline ::vlsir::raw::Layer* LayerShapes::mutable_layer() {
  ::vlsir::raw::Layer* _msg = _internal_mutable_layer();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.LayerShapes.layer)
  return _msg;
}
inline void LayerShapes::set_allocated_layer(::vlsir::raw::Layer* layer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.layer_;
  }
  if (layer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(layer);
    if (message_arena != submessage_arena) {
      layer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.layer_ = layer;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.LayerShapes.layer)
}

// repeated .vlsir.raw.Rectangle rectangles = 2;
inline int LayerShapes::_internal_rectangles_size() const {
  return _impl_.rectangles_.size();
}
inline int LayerShapes::rectangles_size() const {
  return _internal_rectangles_size();
}
inline void LayerShapes::clear_rectangles() {
  _impl_.rectangles_.Clear();
}
inline ::vlsir::raw::Rectangle* LayerShapes::mutable_rectangles(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.LayerShapes.rectangles)
  return _impl_.rectangles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Rectangle >*
LayerShapes::mutable_rectangles() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.LayerShapes.rectangles)
  return &_impl_.rectangles_;
}
inline const ::vlsir::raw::Rectangle& LayerShapes::_internal_rectangles(int index) const {
  return _impl_.rectangles_.Get(index);
}
inline const ::vlsir::raw::Rectangle& LayerShapes::rectangles(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.LayerShapes.rectangles)
  return _internal_rectangles(index);
}
inline ::vlsir::raw::Rectangle* LayerShapes::_internal_add_rectangles() {
  return _impl_.rectangles_.Add();
}
inline ::vlsir::raw::Rectangle* LayerShapes::add_rectangles() {
  ::vlsir::raw::Rectangle* _add = _internal_add_rectangles();
  // @@protoc_insertion_point(field_add:vlsir.raw.LayerShapes.rectangles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Rectangle >&
LayerShapes::rectangles() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.LayerShapes.rectangles)
  return _impl_.rectangles_;
}

// repeated .vlsir.raw.Polygon polygons = 3;
inline int LayerShapes::_internal_polygons_size() const {
  return _impl_.polygons_.size();
}
inline int LayerShapes::polygons_size() const {
  return _internal_polygons_size();
}
inline void LayerShapes::clear_polygons() {
  _impl_.polygons_.Clear();
}
inline ::vlsir::raw::Polygon* LayerShapes::mutable_polygons(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.LayerShapes.polygons)
  return _impl_.polygons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Polygon >*
LayerShapes::mutable_polygons() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.LayerShapes.polygons)
  return &_impl_.polygons_;
}
inline const ::vlsir::raw::Polygon& LayerShapes::_internal_polygons(int index) const {
  return _impl_.polygons_.Get(index);
}
inline const ::vlsir::raw::Polygon& LayerShapes::polygons(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.LayerShapes.polygons)
  return _internal_polygons(index);
}
inline ::vlsir::raw::Polygon* LayerShapes::_internal_add_polygons() {
  return _impl_.polygons_.Add();
}
inline ::vlsir::raw::Polygon* LayerShapes::add_polygons() {
  ::vlsir::raw::Polygon* _add = _internal_add_polygons();
  // @@protoc_insertion_point(field_add:vlsir.raw.LayerShapes.polygons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Polygon >&
LayerShapes::polygons() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.LayerShapes.polygons)
  return _impl_.polygons_;
}

// repeated .vlsir.raw.Path paths = 4;
inline int LayerShapes::_internal_paths_size() const {
  return _impl_.paths_.size();
}
inline int LayerShapes::paths_size() const {
  return _internal_paths_size();
}
inline void LayerShapes::clear_paths() {
  _impl_.paths_.Clear();
}
inline ::vlsir::raw::Path* LayerShapes::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.LayerShapes.paths)
  return _impl_.paths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Path >*
LayerShapes::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.LayerShapes.paths)
  return &_impl_.paths_;
}
inline const ::vlsir::raw::Path& LayerShapes::_internal_paths(int index) const {
  return _impl_.paths_.Get(index);
}
inline const ::vlsir::raw::Path& LayerShapes::paths(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.LayerShapes.paths)
  return _internal_paths(index);
}
inline ::vlsir::raw::Path* LayerShapes::_internal_add_paths() {
  return _impl_.paths_.Add();
}
inline ::vlsir::raw::Path* LayerShapes::add_paths() {
  ::vlsir::raw::Path* _add = _internal_add_paths();
  // @@protoc_insertion_point(field_add:vlsir.raw.LayerShapes.paths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Path >&
LayerShapes::paths() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.LayerShapes.paths)
  return _impl_.paths_;
}

// -------------------------------------------------------------------

// TextElement

// string string = 1;
inline void TextElement::clear_string() {
  _impl_.string_.ClearToEmpty();
}
inline const std::string& TextElement::string() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.TextElement.string)
  return _internal_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextElement::set_string(ArgT0&& arg0, ArgT... args) {
 
 _impl_.string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.raw.TextElement.string)
}
inline std::string* TextElement::mutable_string() {
  std::string* _s = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.TextElement.string)
  return _s;
}
inline const std::string& TextElement::_internal_string() const {
  return _impl_.string_.Get();
}
inline void TextElement::_internal_set_string(const std::string& value) {
  
  _impl_.string_.Set(value, GetArenaForAllocation());
}
inline std::string* TextElement::_internal_mutable_string() {
  
  return _impl_.string_.Mutable(GetArenaForAllocation());
}
inline std::string* TextElement::release_string() {
  // @@protoc_insertion_point(field_release:vlsir.raw.TextElement.string)
  return _impl_.string_.Release();
}
inline void TextElement::set_allocated_string(std::string* string) {
  if (string != nullptr) {
    
  } else {
    
  }
  _impl_.string_.SetAllocated(string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.string_.IsDefault()) {
    _impl_.string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.TextElement.string)
}

// .vlsir.raw.Point loc = 2;
inline bool TextElement::_internal_has_loc() const {
  return this != internal_default_instance() && _impl_.loc_ != nullptr;
}
inline bool TextElement::has_loc() const {
  return _internal_has_loc();
}
inline void TextElement::clear_loc() {
  if (GetArenaForAllocation() == nullptr && _impl_.loc_ != nullptr) {
    delete _impl_.loc_;
  }
  _impl_.loc_ = nullptr;
}
inline const ::vlsir::raw::Point& TextElement::_internal_loc() const {
  const ::vlsir::raw::Point* p = _impl_.loc_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::raw::Point&>(
      ::vlsir::raw::_Point_default_instance_);
}
inline const ::vlsir::raw::Point& TextElement::loc() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.TextElement.loc)
  return _internal_loc();
}
inline void TextElement::unsafe_arena_set_allocated_loc(
    ::vlsir::raw::Point* loc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.loc_);
  }
  _impl_.loc_ = loc;
  if (loc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.TextElement.loc)
}
inline ::vlsir::raw::Point* TextElement::release_loc() {
  
  ::vlsir::raw::Point* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::raw::Point* TextElement::unsafe_arena_release_loc() {
  // @@protoc_insertion_point(field_release:vlsir.raw.TextElement.loc)
  
  ::vlsir::raw::Point* temp = _impl_.loc_;
  _impl_.loc_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Point* TextElement::_internal_mutable_loc() {
  
  if (_impl_.loc_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Point>(GetArenaForAllocation());
    _impl_.loc_ = p;
  }
  return _impl_.loc_;
}
inline ::vlsir::raw::Point* TextElement::mutable_loc() {
  ::vlsir::raw::Point* _msg = _internal_mutable_loc();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.TextElement.loc)
  return _msg;
}
inline void TextElement::set_allocated_loc(::vlsir::raw::Point* loc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.loc_;
  }
  if (loc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loc);
    if (message_arena != submessage_arena) {
      loc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loc, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.loc_ = loc;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.TextElement.loc)
}

// -------------------------------------------------------------------

// Instance

// string name = 1;
inline void Instance::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Instance::name() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Instance.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Instance::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.raw.Instance.name)
}
inline std::string* Instance::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Instance.name)
  return _s;
}
inline const std::string& Instance::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Instance::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Instance::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Instance::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Instance.name)
  return _impl_.name_.Release();
}
inline void Instance::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Instance.name)
}

// .vlsir.utils.Reference cell = 3;
inline bool Instance::_internal_has_cell() const {
  return this != internal_default_instance() && _impl_.cell_ != nullptr;
}
inline bool Instance::has_cell() const {
  return _internal_has_cell();
}
inline const ::vlsir::utils::Reference& Instance::_internal_cell() const {
  const ::vlsir::utils::Reference* p = _impl_.cell_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::utils::Reference&>(
      ::vlsir::utils::_Reference_default_instance_);
}
inline const ::vlsir::utils::Reference& Instance::cell() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Instance.cell)
  return _internal_cell();
}
inline void Instance::unsafe_arena_set_allocated_cell(
    ::vlsir::utils::Reference* cell) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  _impl_.cell_ = cell;
  if (cell) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Instance.cell)
}
inline ::vlsir::utils::Reference* Instance::release_cell() {
  
  ::vlsir::utils::Reference* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::utils::Reference* Instance::unsafe_arena_release_cell() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Instance.cell)
  
  ::vlsir::utils::Reference* temp = _impl_.cell_;
  _impl_.cell_ = nullptr;
  return temp;
}
inline ::vlsir::utils::Reference* Instance::_internal_mutable_cell() {
  
  if (_impl_.cell_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::utils::Reference>(GetArenaForAllocation());
    _impl_.cell_ = p;
  }
  return _impl_.cell_;
}
inline ::vlsir::utils::Reference* Instance::mutable_cell() {
  ::vlsir::utils::Reference* _msg = _internal_mutable_cell();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Instance.cell)
  return _msg;
}
inline void Instance::set_allocated_cell(::vlsir::utils::Reference* cell) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cell_);
  }
  if (cell) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cell));
    if (message_arena != submessage_arena) {
      cell = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cell, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cell_ = cell;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Instance.cell)
}

// .vlsir.raw.Point origin_location = 4;
inline bool Instance::_internal_has_origin_location() const {
  return this != internal_default_instance() && _impl_.origin_location_ != nullptr;
}
inline bool Instance::has_origin_location() const {
  return _internal_has_origin_location();
}
inline void Instance::clear_origin_location() {
  if (GetArenaForAllocation() == nullptr && _impl_.origin_location_ != nullptr) {
    delete _impl_.origin_location_;
  }
  _impl_.origin_location_ = nullptr;
}
inline const ::vlsir::raw::Point& Instance::_internal_origin_location() const {
  const ::vlsir::raw::Point* p = _impl_.origin_location_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::raw::Point&>(
      ::vlsir::raw::_Point_default_instance_);
}
inline const ::vlsir::raw::Point& Instance::origin_location() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Instance.origin_location)
  return _internal_origin_location();
}
inline void Instance::unsafe_arena_set_allocated_origin_location(
    ::vlsir::raw::Point* origin_location) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.origin_location_);
  }
  _impl_.origin_location_ = origin_location;
  if (origin_location) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Instance.origin_location)
}
inline ::vlsir::raw::Point* Instance::release_origin_location() {
  
  ::vlsir::raw::Point* temp = _impl_.origin_location_;
  _impl_.origin_location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::raw::Point* Instance::unsafe_arena_release_origin_location() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Instance.origin_location)
  
  ::vlsir::raw::Point* temp = _impl_.origin_location_;
  _impl_.origin_location_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Point* Instance::_internal_mutable_origin_location() {
  
  if (_impl_.origin_location_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Point>(GetArenaForAllocation());
    _impl_.origin_location_ = p;
  }
  return _impl_.origin_location_;
}
inline ::vlsir::raw::Point* Instance::mutable_origin_location() {
  ::vlsir::raw::Point* _msg = _internal_mutable_origin_location();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Instance.origin_location)
  return _msg;
}
inline void Instance::set_allocated_origin_location(::vlsir::raw::Point* origin_location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.origin_location_;
  }
  if (origin_location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(origin_location);
    if (message_arena != submessage_arena) {
      origin_location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin_location, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.origin_location_ = origin_location;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Instance.origin_location)
}

// bool reflect_vert = 6;
inline void Instance::clear_reflect_vert() {
  _impl_.reflect_vert_ = false;
}
inline bool Instance::_internal_reflect_vert() const {
  return _impl_.reflect_vert_;
}
inline bool Instance::reflect_vert() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Instance.reflect_vert)
  return _internal_reflect_vert();
}
inline void Instance::_internal_set_reflect_vert(bool value) {
  
  _impl_.reflect_vert_ = value;
}
inline void Instance::set_reflect_vert(bool value) {
  _internal_set_reflect_vert(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Instance.reflect_vert)
}

// int32 rotation_clockwise_degrees = 7;
inline void Instance::clear_rotation_clockwise_degrees() {
  _impl_.rotation_clockwise_degrees_ = 0;
}
inline int32_t Instance::_internal_rotation_clockwise_degrees() const {
  return _impl_.rotation_clockwise_degrees_;
}
inline int32_t Instance::rotation_clockwise_degrees() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Instance.rotation_clockwise_degrees)
  return _internal_rotation_clockwise_degrees();
}
inline void Instance::_internal_set_rotation_clockwise_degrees(int32_t value) {
  
  _impl_.rotation_clockwise_degrees_ = value;
}
inline void Instance::set_rotation_clockwise_degrees(int32_t value) {
  _internal_set_rotation_clockwise_degrees(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Instance.rotation_clockwise_degrees)
}

// -------------------------------------------------------------------

// Layout

// string name = 1;
inline void Layout::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Layout::name() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Layout.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Layout::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.raw.Layout.name)
}
inline std::string* Layout::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Layout.name)
  return _s;
}
inline const std::string& Layout::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Layout::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Layout::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Layout::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Layout.name)
  return _impl_.name_.Release();
}
inline void Layout::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Layout.name)
}

// repeated .vlsir.raw.LayerShapes shapes = 2;
inline int Layout::_internal_shapes_size() const {
  return _impl_.shapes_.size();
}
inline int Layout::shapes_size() const {
  return _internal_shapes_size();
}
inline void Layout::clear_shapes() {
  _impl_.shapes_.Clear();
}
inline ::vlsir::raw::LayerShapes* Layout::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Layout.shapes)
  return _impl_.shapes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >*
Layout::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Layout.shapes)
  return &_impl_.shapes_;
}
inline const ::vlsir::raw::LayerShapes& Layout::_internal_shapes(int index) const {
  return _impl_.shapes_.Get(index);
}
inline const ::vlsir::raw::LayerShapes& Layout::shapes(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Layout.shapes)
  return _internal_shapes(index);
}
inline ::vlsir::raw::LayerShapes* Layout::_internal_add_shapes() {
  return _impl_.shapes_.Add();
}
inline ::vlsir::raw::LayerShapes* Layout::add_shapes() {
  ::vlsir::raw::LayerShapes* _add = _internal_add_shapes();
  // @@protoc_insertion_point(field_add:vlsir.raw.Layout.shapes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >&
Layout::shapes() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Layout.shapes)
  return _impl_.shapes_;
}

// repeated .vlsir.raw.Instance instances = 3;
inline int Layout::_internal_instances_size() const {
  return _impl_.instances_.size();
}
inline int Layout::instances_size() const {
  return _internal_instances_size();
}
inline void Layout::clear_instances() {
  _impl_.instances_.Clear();
}
inline ::vlsir::raw::Instance* Layout::mutable_instances(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Layout.instances)
  return _impl_.instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Instance >*
Layout::mutable_instances() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Layout.instances)
  return &_impl_.instances_;
}
inline const ::vlsir::raw::Instance& Layout::_internal_instances(int index) const {
  return _impl_.instances_.Get(index);
}
inline const ::vlsir::raw::Instance& Layout::instances(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Layout.instances)
  return _internal_instances(index);
}
inline ::vlsir::raw::Instance* Layout::_internal_add_instances() {
  return _impl_.instances_.Add();
}
inline ::vlsir::raw::Instance* Layout::add_instances() {
  ::vlsir::raw::Instance* _add = _internal_add_instances();
  // @@protoc_insertion_point(field_add:vlsir.raw.Layout.instances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Instance >&
Layout::instances() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Layout.instances)
  return _impl_.instances_;
}

// repeated .vlsir.raw.TextElement annotations = 4;
inline int Layout::_internal_annotations_size() const {
  return _impl_.annotations_.size();
}
inline int Layout::annotations_size() const {
  return _internal_annotations_size();
}
inline void Layout::clear_annotations() {
  _impl_.annotations_.Clear();
}
inline ::vlsir::raw::TextElement* Layout::mutable_annotations(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Layout.annotations)
  return _impl_.annotations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::TextElement >*
Layout::mutable_annotations() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Layout.annotations)
  return &_impl_.annotations_;
}
inline const ::vlsir::raw::TextElement& Layout::_internal_annotations(int index) const {
  return _impl_.annotations_.Get(index);
}
inline const ::vlsir::raw::TextElement& Layout::annotations(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Layout.annotations)
  return _internal_annotations(index);
}
inline ::vlsir::raw::TextElement* Layout::_internal_add_annotations() {
  return _impl_.annotations_.Add();
}
inline ::vlsir::raw::TextElement* Layout::add_annotations() {
  ::vlsir::raw::TextElement* _add = _internal_add_annotations();
  // @@protoc_insertion_point(field_add:vlsir.raw.Layout.annotations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::TextElement >&
Layout::annotations() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Layout.annotations)
  return _impl_.annotations_;
}

// -------------------------------------------------------------------

// Abstract

// string name = 1;
inline void Abstract::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Abstract::name() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Abstract.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Abstract::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.raw.Abstract.name)
}
inline std::string* Abstract::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Abstract.name)
  return _s;
}
inline const std::string& Abstract::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Abstract::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Abstract::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Abstract::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Abstract.name)
  return _impl_.name_.Release();
}
inline void Abstract::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Abstract.name)
}

// .vlsir.raw.Polygon outline = 2;
inline bool Abstract::_internal_has_outline() const {
  return this != internal_default_instance() && _impl_.outline_ != nullptr;
}
inline bool Abstract::has_outline() const {
  return _internal_has_outline();
}
inline void Abstract::clear_outline() {
  if (GetArenaForAllocation() == nullptr && _impl_.outline_ != nullptr) {
    delete _impl_.outline_;
  }
  _impl_.outline_ = nullptr;
}
inline const ::vlsir::raw::Polygon& Abstract::_internal_outline() const {
  const ::vlsir::raw::Polygon* p = _impl_.outline_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::raw::Polygon&>(
      ::vlsir::raw::_Polygon_default_instance_);
}
inline const ::vlsir::raw::Polygon& Abstract::outline() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Abstract.outline)
  return _internal_outline();
}
inline void Abstract::unsafe_arena_set_allocated_outline(
    ::vlsir::raw::Polygon* outline) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.outline_);
  }
  _impl_.outline_ = outline;
  if (outline) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Abstract.outline)
}
inline ::vlsir::raw::Polygon* Abstract::release_outline() {
  
  ::vlsir::raw::Polygon* temp = _impl_.outline_;
  _impl_.outline_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::raw::Polygon* Abstract::unsafe_arena_release_outline() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Abstract.outline)
  
  ::vlsir::raw::Polygon* temp = _impl_.outline_;
  _impl_.outline_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Polygon* Abstract::_internal_mutable_outline() {
  
  if (_impl_.outline_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Polygon>(GetArenaForAllocation());
    _impl_.outline_ = p;
  }
  return _impl_.outline_;
}
inline ::vlsir::raw::Polygon* Abstract::mutable_outline() {
  ::vlsir::raw::Polygon* _msg = _internal_mutable_outline();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Abstract.outline)
  return _msg;
}
inline void Abstract::set_allocated_outline(::vlsir::raw::Polygon* outline) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.outline_;
  }
  if (outline) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(outline);
    if (message_arena != submessage_arena) {
      outline = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outline, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.outline_ = outline;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Abstract.outline)
}

// repeated .vlsir.raw.AbstractPort ports = 4;
inline int Abstract::_internal_ports_size() const {
  return _impl_.ports_.size();
}
inline int Abstract::ports_size() const {
  return _internal_ports_size();
}
inline void Abstract::clear_ports() {
  _impl_.ports_.Clear();
}
inline ::vlsir::raw::AbstractPort* Abstract::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Abstract.ports)
  return _impl_.ports_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::AbstractPort >*
Abstract::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Abstract.ports)
  return &_impl_.ports_;
}
inline const ::vlsir::raw::AbstractPort& Abstract::_internal_ports(int index) const {
  return _impl_.ports_.Get(index);
}
inline const ::vlsir::raw::AbstractPort& Abstract::ports(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Abstract.ports)
  return _internal_ports(index);
}
inline ::vlsir::raw::AbstractPort* Abstract::_internal_add_ports() {
  return _impl_.ports_.Add();
}
inline ::vlsir::raw::AbstractPort* Abstract::add_ports() {
  ::vlsir::raw::AbstractPort* _add = _internal_add_ports();
  // @@protoc_insertion_point(field_add:vlsir.raw.Abstract.ports)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::AbstractPort >&
Abstract::ports() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Abstract.ports)
  return _impl_.ports_;
}

// repeated .vlsir.raw.LayerShapes blockages = 5;
inline int Abstract::_internal_blockages_size() const {
  return _impl_.blockages_.size();
}
inline int Abstract::blockages_size() const {
  return _internal_blockages_size();
}
inline void Abstract::clear_blockages() {
  _impl_.blockages_.Clear();
}
inline ::vlsir::raw::LayerShapes* Abstract::mutable_blockages(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Abstract.blockages)
  return _impl_.blockages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >*
Abstract::mutable_blockages() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Abstract.blockages)
  return &_impl_.blockages_;
}
inline const ::vlsir::raw::LayerShapes& Abstract::_internal_blockages(int index) const {
  return _impl_.blockages_.Get(index);
}
inline const ::vlsir::raw::LayerShapes& Abstract::blockages(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Abstract.blockages)
  return _internal_blockages(index);
}
inline ::vlsir::raw::LayerShapes* Abstract::_internal_add_blockages() {
  return _impl_.blockages_.Add();
}
inline ::vlsir::raw::LayerShapes* Abstract::add_blockages() {
  ::vlsir::raw::LayerShapes* _add = _internal_add_blockages();
  // @@protoc_insertion_point(field_add:vlsir.raw.Abstract.blockages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >&
Abstract::blockages() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Abstract.blockages)
  return _impl_.blockages_;
}

// -------------------------------------------------------------------

// AbstractPort

// string net = 1;
inline void AbstractPort::clear_net() {
  _impl_.net_.ClearToEmpty();
}
inline const std::string& AbstractPort::net() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.AbstractPort.net)
  return _internal_net();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AbstractPort::set_net(ArgT0&& arg0, ArgT... args) {
 
 _impl_.net_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.raw.AbstractPort.net)
}
inline std::string* AbstractPort::mutable_net() {
  std::string* _s = _internal_mutable_net();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.AbstractPort.net)
  return _s;
}
inline const std::string& AbstractPort::_internal_net() const {
  return _impl_.net_.Get();
}
inline void AbstractPort::_internal_set_net(const std::string& value) {
  
  _impl_.net_.Set(value, GetArenaForAllocation());
}
inline std::string* AbstractPort::_internal_mutable_net() {
  
  return _impl_.net_.Mutable(GetArenaForAllocation());
}
inline std::string* AbstractPort::release_net() {
  // @@protoc_insertion_point(field_release:vlsir.raw.AbstractPort.net)
  return _impl_.net_.Release();
}
inline void AbstractPort::set_allocated_net(std::string* net) {
  if (net != nullptr) {
    
  } else {
    
  }
  _impl_.net_.SetAllocated(net, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.net_.IsDefault()) {
    _impl_.net_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.AbstractPort.net)
}

// repeated .vlsir.raw.LayerShapes shapes = 2;
inline int AbstractPort::_internal_shapes_size() const {
  return _impl_.shapes_.size();
}
inline int AbstractPort::shapes_size() const {
  return _internal_shapes_size();
}
inline void AbstractPort::clear_shapes() {
  _impl_.shapes_.Clear();
}
inline ::vlsir::raw::LayerShapes* AbstractPort::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.AbstractPort.shapes)
  return _impl_.shapes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >*
AbstractPort::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.AbstractPort.shapes)
  return &_impl_.shapes_;
}
inline const ::vlsir::raw::LayerShapes& AbstractPort::_internal_shapes(int index) const {
  return _impl_.shapes_.Get(index);
}
inline const ::vlsir::raw::LayerShapes& AbstractPort::shapes(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.AbstractPort.shapes)
  return _internal_shapes(index);
}
inline ::vlsir::raw::LayerShapes* AbstractPort::_internal_add_shapes() {
  return _impl_.shapes_.Add();
}
inline ::vlsir::raw::LayerShapes* AbstractPort::add_shapes() {
  ::vlsir::raw::LayerShapes* _add = _internal_add_shapes();
  // @@protoc_insertion_point(field_add:vlsir.raw.AbstractPort.shapes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::LayerShapes >&
AbstractPort::shapes() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.AbstractPort.shapes)
  return _impl_.shapes_;
}

// -------------------------------------------------------------------

// Cell

// string name = 1;
inline void Cell::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Cell::name() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Cell.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Cell::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.raw.Cell.name)
}
inline std::string* Cell::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Cell.name)
  return _s;
}
inline const std::string& Cell::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Cell::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Cell::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Cell::release_name() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Cell.name)
  return _impl_.name_.Release();
}
inline void Cell::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Cell.name)
}

// .vlsir.circuit.Interface interface = 10;
inline bool Cell::_internal_has_interface() const {
  return this != internal_default_instance() && _impl_.interface_ != nullptr;
}
inline bool Cell::has_interface() const {
  return _internal_has_interface();
}
inline const ::vlsir::circuit::Interface& Cell::_internal_interface() const {
  const ::vlsir::circuit::Interface* p = _impl_.interface_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::circuit::Interface&>(
      ::vlsir::circuit::_Interface_default_instance_);
}
inline const ::vlsir::circuit::Interface& Cell::interface() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Cell.interface)
  return _internal_interface();
}
inline void Cell::unsafe_arena_set_allocated_interface(
    ::vlsir::circuit::Interface* interface) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interface_);
  }
  _impl_.interface_ = interface;
  if (interface) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Cell.interface)
}
inline ::vlsir::circuit::Interface* Cell::release_interface() {
  
  ::vlsir::circuit::Interface* temp = _impl_.interface_;
  _impl_.interface_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::circuit::Interface* Cell::unsafe_arena_release_interface() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Cell.interface)
  
  ::vlsir::circuit::Interface* temp = _impl_.interface_;
  _impl_.interface_ = nullptr;
  return temp;
}
inline ::vlsir::circuit::Interface* Cell::_internal_mutable_interface() {
  
  if (_impl_.interface_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::circuit::Interface>(GetArenaForAllocation());
    _impl_.interface_ = p;
  }
  return _impl_.interface_;
}
inline ::vlsir::circuit::Interface* Cell::mutable_interface() {
  ::vlsir::circuit::Interface* _msg = _internal_mutable_interface();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Cell.interface)
  return _msg;
}
inline void Cell::set_allocated_interface(::vlsir::circuit::Interface* interface) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.interface_);
  }
  if (interface) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(interface));
    if (message_arena != submessage_arena) {
      interface = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, interface, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.interface_ = interface;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Cell.interface)
}

// .vlsir.circuit.Module module = 11;
inline bool Cell::_internal_has_module() const {
  return this != internal_default_instance() && _impl_.module_ != nullptr;
}
inline bool Cell::has_module() const {
  return _internal_has_module();
}
inline const ::vlsir::circuit::Module& Cell::_internal_module() const {
  const ::vlsir::circuit::Module* p = _impl_.module_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::circuit::Module&>(
      ::vlsir::circuit::_Module_default_instance_);
}
inline const ::vlsir::circuit::Module& Cell::module() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Cell.module)
  return _internal_module();
}
inline void Cell::unsafe_arena_set_allocated_module(
    ::vlsir::circuit::Module* module) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.module_);
  }
  _impl_.module_ = module;
  if (module) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Cell.module)
}
inline ::vlsir::circuit::Module* Cell::release_module() {
  
  ::vlsir::circuit::Module* temp = _impl_.module_;
  _impl_.module_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::circuit::Module* Cell::unsafe_arena_release_module() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Cell.module)
  
  ::vlsir::circuit::Module* temp = _impl_.module_;
  _impl_.module_ = nullptr;
  return temp;
}
inline ::vlsir::circuit::Module* Cell::_internal_mutable_module() {
  
  if (_impl_.module_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::circuit::Module>(GetArenaForAllocation());
    _impl_.module_ = p;
  }
  return _impl_.module_;
}
inline ::vlsir::circuit::Module* Cell::mutable_module() {
  ::vlsir::circuit::Module* _msg = _internal_mutable_module();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Cell.module)
  return _msg;
}
inline void Cell::set_allocated_module(::vlsir::circuit::Module* module) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.module_);
  }
  if (module) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(module));
    if (message_arena != submessage_arena) {
      module = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.module_ = module;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Cell.module)
}

// .vlsir.raw.Abstract abstract = 12;
inline bool Cell::_internal_has_abstract() const {
  return this != internal_default_instance() && _impl_.abstract_ != nullptr;
}
inline bool Cell::has_abstract() const {
  return _internal_has_abstract();
}
inline void Cell::clear_abstract() {
  if (GetArenaForAllocation() == nullptr && _impl_.abstract_ != nullptr) {
    delete _impl_.abstract_;
  }
  _impl_.abstract_ = nullptr;
}
inline const ::vlsir::raw::Abstract& Cell::_internal_abstract() const {
  const ::vlsir::raw::Abstract* p = _impl_.abstract_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::raw::Abstract&>(
      ::vlsir::raw::_Abstract_default_instance_);
}
inline const ::vlsir::raw::Abstract& Cell::abstract() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Cell.abstract)
  return _internal_abstract();
}
inline void Cell::unsafe_arena_set_allocated_abstract(
    ::vlsir::raw::Abstract* abstract) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.abstract_);
  }
  _impl_.abstract_ = abstract;
  if (abstract) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Cell.abstract)
}
inline ::vlsir::raw::Abstract* Cell::release_abstract() {
  
  ::vlsir::raw::Abstract* temp = _impl_.abstract_;
  _impl_.abstract_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::raw::Abstract* Cell::unsafe_arena_release_abstract() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Cell.abstract)
  
  ::vlsir::raw::Abstract* temp = _impl_.abstract_;
  _impl_.abstract_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Abstract* Cell::_internal_mutable_abstract() {
  
  if (_impl_.abstract_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Abstract>(GetArenaForAllocation());
    _impl_.abstract_ = p;
  }
  return _impl_.abstract_;
}
inline ::vlsir::raw::Abstract* Cell::mutable_abstract() {
  ::vlsir::raw::Abstract* _msg = _internal_mutable_abstract();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Cell.abstract)
  return _msg;
}
inline void Cell::set_allocated_abstract(::vlsir::raw::Abstract* abstract) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.abstract_;
  }
  if (abstract) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(abstract);
    if (message_arena != submessage_arena) {
      abstract = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, abstract, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.abstract_ = abstract;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Cell.abstract)
}

// .vlsir.raw.Layout layout = 13;
inline bool Cell::_internal_has_layout() const {
  return this != internal_default_instance() && _impl_.layout_ != nullptr;
}
inline bool Cell::has_layout() const {
  return _internal_has_layout();
}
inline void Cell::clear_layout() {
  if (GetArenaForAllocation() == nullptr && _impl_.layout_ != nullptr) {
    delete _impl_.layout_;
  }
  _impl_.layout_ = nullptr;
}
inline const ::vlsir::raw::Layout& Cell::_internal_layout() const {
  const ::vlsir::raw::Layout* p = _impl_.layout_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::raw::Layout&>(
      ::vlsir::raw::_Layout_default_instance_);
}
inline const ::vlsir::raw::Layout& Cell::layout() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Cell.layout)
  return _internal_layout();
}
inline void Cell::unsafe_arena_set_allocated_layout(
    ::vlsir::raw::Layout* layout) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.layout_);
  }
  _impl_.layout_ = layout;
  if (layout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Cell.layout)
}
inline ::vlsir::raw::Layout* Cell::release_layout() {
  
  ::vlsir::raw::Layout* temp = _impl_.layout_;
  _impl_.layout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::raw::Layout* Cell::unsafe_arena_release_layout() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Cell.layout)
  
  ::vlsir::raw::Layout* temp = _impl_.layout_;
  _impl_.layout_ = nullptr;
  return temp;
}
inline ::vlsir::raw::Layout* Cell::_internal_mutable_layout() {
  
  if (_impl_.layout_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::raw::Layout>(GetArenaForAllocation());
    _impl_.layout_ = p;
  }
  return _impl_.layout_;
}
inline ::vlsir::raw::Layout* Cell::mutable_layout() {
  ::vlsir::raw::Layout* _msg = _internal_mutable_layout();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Cell.layout)
  return _msg;
}
inline void Cell::set_allocated_layout(::vlsir::raw::Layout* layout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.layout_;
  }
  if (layout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(layout);
    if (message_arena != submessage_arena) {
      layout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layout, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.layout_ = layout;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Cell.layout)
}

// -------------------------------------------------------------------

// Library

// string domain = 1;
inline void Library::clear_domain() {
  _impl_.domain_.ClearToEmpty();
}
inline const std::string& Library::domain() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Library.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Library::set_domain(ArgT0&& arg0, ArgT... args) {
 
 _impl_.domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vlsir.raw.Library.domain)
}
inline std::string* Library::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Library.domain)
  return _s;
}
inline const std::string& Library::_internal_domain() const {
  return _impl_.domain_.Get();
}
inline void Library::_internal_set_domain(const std::string& value) {
  
  _impl_.domain_.Set(value, GetArenaForAllocation());
}
inline std::string* Library::_internal_mutable_domain() {
  
  return _impl_.domain_.Mutable(GetArenaForAllocation());
}
inline std::string* Library::release_domain() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Library.domain)
  return _impl_.domain_.Release();
}
inline void Library::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  _impl_.domain_.SetAllocated(domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.domain_.IsDefault()) {
    _impl_.domain_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Library.domain)
}

// .vlsir.raw.Units units = 2;
inline void Library::clear_units() {
  _impl_.units_ = 0;
}
inline ::vlsir::raw::Units Library::_internal_units() const {
  return static_cast< ::vlsir::raw::Units >(_impl_.units_);
}
inline ::vlsir::raw::Units Library::units() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Library.units)
  return _internal_units();
}
inline void Library::_internal_set_units(::vlsir::raw::Units value) {
  
  _impl_.units_ = value;
}
inline void Library::set_units(::vlsir::raw::Units value) {
  _internal_set_units(value);
  // @@protoc_insertion_point(field_set:vlsir.raw.Library.units)
}

// repeated .vlsir.raw.Cell cells = 10;
inline int Library::_internal_cells_size() const {
  return _impl_.cells_.size();
}
inline int Library::cells_size() const {
  return _internal_cells_size();
}
inline void Library::clear_cells() {
  _impl_.cells_.Clear();
}
inline ::vlsir::raw::Cell* Library::mutable_cells(int index) {
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Library.cells)
  return _impl_.cells_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Cell >*
Library::mutable_cells() {
  // @@protoc_insertion_point(field_mutable_list:vlsir.raw.Library.cells)
  return &_impl_.cells_;
}
inline const ::vlsir::raw::Cell& Library::_internal_cells(int index) const {
  return _impl_.cells_.Get(index);
}
inline const ::vlsir::raw::Cell& Library::cells(int index) const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Library.cells)
  return _internal_cells(index);
}
inline ::vlsir::raw::Cell* Library::_internal_add_cells() {
  return _impl_.cells_.Add();
}
inline ::vlsir::raw::Cell* Library::add_cells() {
  ::vlsir::raw::Cell* _add = _internal_add_cells();
  // @@protoc_insertion_point(field_add:vlsir.raw.Library.cells)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vlsir::raw::Cell >&
Library::cells() const {
  // @@protoc_insertion_point(field_list:vlsir.raw.Library.cells)
  return _impl_.cells_;
}

// .vlsir.utils.AuthorMetadata author = 20;
inline bool Library::_internal_has_author() const {
  return this != internal_default_instance() && _impl_.author_ != nullptr;
}
inline bool Library::has_author() const {
  return _internal_has_author();
}
inline const ::vlsir::utils::AuthorMetadata& Library::_internal_author() const {
  const ::vlsir::utils::AuthorMetadata* p = _impl_.author_;
  return p != nullptr ? *p : reinterpret_cast<const ::vlsir::utils::AuthorMetadata&>(
      ::vlsir::utils::_AuthorMetadata_default_instance_);
}
inline const ::vlsir::utils::AuthorMetadata& Library::author() const {
  // @@protoc_insertion_point(field_get:vlsir.raw.Library.author)
  return _internal_author();
}
inline void Library::unsafe_arena_set_allocated_author(
    ::vlsir::utils::AuthorMetadata* author) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.author_);
  }
  _impl_.author_ = author;
  if (author) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vlsir.raw.Library.author)
}
inline ::vlsir::utils::AuthorMetadata* Library::release_author() {
  
  ::vlsir::utils::AuthorMetadata* temp = _impl_.author_;
  _impl_.author_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vlsir::utils::AuthorMetadata* Library::unsafe_arena_release_author() {
  // @@protoc_insertion_point(field_release:vlsir.raw.Library.author)
  
  ::vlsir::utils::AuthorMetadata* temp = _impl_.author_;
  _impl_.author_ = nullptr;
  return temp;
}
inline ::vlsir::utils::AuthorMetadata* Library::_internal_mutable_author() {
  
  if (_impl_.author_ == nullptr) {
    auto* p = CreateMaybeMessage<::vlsir::utils::AuthorMetadata>(GetArenaForAllocation());
    _impl_.author_ = p;
  }
  return _impl_.author_;
}
inline ::vlsir::utils::AuthorMetadata* Library::mutable_author() {
  ::vlsir::utils::AuthorMetadata* _msg = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:vlsir.raw.Library.author)
  return _msg;
}
inline void Library::set_allocated_author(::vlsir::utils::AuthorMetadata* author) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.author_);
  }
  if (author) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(author));
    if (message_arena != submessage_arena) {
      author = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, author, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.author_ = author;
  // @@protoc_insertion_point(field_set_allocated:vlsir.raw.Library.author)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace raw
}  // namespace vlsir

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vlsir::raw::Units> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vlsir::raw::Units>() {
  return ::vlsir::raw::Units_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_layout_2fraw_2eproto
