// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: layout/tetris.proto

#include "layout/tetris.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace vlsir {
namespace tetris {
PROTOBUF_CONSTEXPR Library::Library(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cells_)*/{}
  , /*decltype(_impl_.domain_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.author_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LibraryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LibraryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LibraryDefaultTypeInternal() {}
  union {
    Library _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LibraryDefaultTypeInternal _Library_default_instance_;
PROTOBUF_CONSTEXPR Cell::Cell(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.interface_)*/nullptr
  , /*decltype(_impl_.module_)*/nullptr
  , /*decltype(_impl_.abstract_)*/nullptr
  , /*decltype(_impl_.layout_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CellDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CellDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CellDefaultTypeInternal() {}
  union {
    Cell _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CellDefaultTypeInternal _Cell_default_instance_;
PROTOBUF_CONSTEXPR Layout::Layout(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.instances_)*/{}
  , /*decltype(_impl_.assignments_)*/{}
  , /*decltype(_impl_.cuts_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.outline_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LayoutDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LayoutDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LayoutDefaultTypeInternal() {}
  union {
    Layout _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LayoutDefaultTypeInternal _Layout_default_instance_;
PROTOBUF_CONSTEXPR Assign::Assign(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.net_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.at_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AssignDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AssignDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AssignDefaultTypeInternal() {}
  union {
    Assign _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AssignDefaultTypeInternal _Assign_default_instance_;
PROTOBUF_CONSTEXPR TrackCross::TrackCross(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.track_)*/nullptr
  , /*decltype(_impl_.cross_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TrackCrossDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrackCrossDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrackCrossDefaultTypeInternal() {}
  union {
    TrackCross _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrackCrossDefaultTypeInternal _TrackCross_default_instance_;
PROTOBUF_CONSTEXPR TrackRef::TrackRef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.layer_)*/int64_t{0}
  , /*decltype(_impl_.track_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TrackRefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrackRefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrackRefDefaultTypeInternal() {}
  union {
    TrackRef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrackRefDefaultTypeInternal _TrackRef_default_instance_;
PROTOBUF_CONSTEXPR Outline::Outline(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/{}
  , /*decltype(_impl_._x_cached_byte_size_)*/{0}
  , /*decltype(_impl_.y_)*/{}
  , /*decltype(_impl_._y_cached_byte_size_)*/{0}
  , /*decltype(_impl_.metals_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OutlineDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OutlineDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OutlineDefaultTypeInternal() {}
  union {
    Outline _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OutlineDefaultTypeInternal _Outline_default_instance_;
PROTOBUF_CONSTEXPR Abstract::Abstract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ports_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.outline_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AbstractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AbstractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AbstractDefaultTypeInternal() {}
  union {
    Abstract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AbstractDefaultTypeInternal _Abstract_default_instance_;
PROTOBUF_CONSTEXPR AbstractPort_EdgePort::AbstractPort_EdgePort(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.track_)*/nullptr
  , /*decltype(_impl_.side_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AbstractPort_EdgePortDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AbstractPort_EdgePortDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AbstractPort_EdgePortDefaultTypeInternal() {}
  union {
    AbstractPort_EdgePort _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AbstractPort_EdgePortDefaultTypeInternal _AbstractPort_EdgePort_default_instance_;
PROTOBUF_CONSTEXPR AbstractPort_ZTopEdgePort::AbstractPort_ZTopEdgePort(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.into_)*/nullptr
  , /*decltype(_impl_.track_)*/int64_t{0}
  , /*decltype(_impl_.side_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AbstractPort_ZTopEdgePortDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AbstractPort_ZTopEdgePortDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AbstractPort_ZTopEdgePortDefaultTypeInternal() {}
  union {
    AbstractPort_ZTopEdgePort _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AbstractPort_ZTopEdgePortDefaultTypeInternal _AbstractPort_ZTopEdgePort_default_instance_;
PROTOBUF_CONSTEXPR AbstractPort_ZTopInner::AbstractPort_ZTopInner(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.locs_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AbstractPort_ZTopInnerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AbstractPort_ZTopInnerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AbstractPort_ZTopInnerDefaultTypeInternal() {}
  union {
    AbstractPort_ZTopInner _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AbstractPort_ZTopInnerDefaultTypeInternal _AbstractPort_ZTopInner_default_instance_;
PROTOBUF_CONSTEXPR AbstractPort::AbstractPort(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.net_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.kind_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct AbstractPortDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AbstractPortDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AbstractPortDefaultTypeInternal() {}
  union {
    AbstractPort _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AbstractPortDefaultTypeInternal _AbstractPort_default_instance_;
PROTOBUF_CONSTEXPR Instance::Instance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cell_)*/nullptr
  , /*decltype(_impl_.loc_)*/nullptr
  , /*decltype(_impl_.reflect_horiz_)*/false
  , /*decltype(_impl_.reflect_vert_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InstanceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InstanceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InstanceDefaultTypeInternal() {}
  union {
    Instance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InstanceDefaultTypeInternal _Instance_default_instance_;
PROTOBUF_CONSTEXPR Place::Place(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.place_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct PlaceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlaceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlaceDefaultTypeInternal() {}
  union {
    Place _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlaceDefaultTypeInternal _Place_default_instance_;
PROTOBUF_CONSTEXPR RelPlace::RelPlace(
    ::_pbi::ConstantInitialized) {}
struct RelPlaceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RelPlaceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RelPlaceDefaultTypeInternal() {}
  union {
    RelPlace _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RelPlaceDefaultTypeInternal _RelPlace_default_instance_;
PROTOBUF_CONSTEXPR Stack::Stack(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.metals_)*/{}
  , /*decltype(_impl_.vias_)*/{}
  , /*decltype(_impl_.prim_)*/nullptr
  , /*decltype(_impl_.boundary_layer_)*/nullptr
  , /*decltype(_impl_.units_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StackDefaultTypeInternal() {}
  union {
    Stack _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StackDefaultTypeInternal _Stack_default_instance_;
PROTOBUF_CONSTEXPR LayerEnum::LayerEnum(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.index_)*/int64_t{0}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LayerEnumDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LayerEnumDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LayerEnumDefaultTypeInternal() {}
  union {
    LayerEnum _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LayerEnumDefaultTypeInternal _LayerEnum_default_instance_;
PROTOBUF_CONSTEXPR MetalLayer::MetalLayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.raw_)*/nullptr
  , /*decltype(_impl_.cutsize_)*/int64_t{0}
  , /*decltype(_impl_.dir_)*/0
  , /*decltype(_impl_.flip_)*/false
  , /*decltype(_impl_.offset_)*/int64_t{0}
  , /*decltype(_impl_.overlap_)*/int64_t{0}
  , /*decltype(_impl_.prim_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MetalLayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MetalLayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MetalLayerDefaultTypeInternal() {}
  union {
    MetalLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MetalLayerDefaultTypeInternal _MetalLayer_default_instance_;
PROTOBUF_CONSTEXPR ViaLayer::ViaLayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.top_)*/nullptr
  , /*decltype(_impl_.bot_)*/nullptr
  , /*decltype(_impl_.size_)*/nullptr
  , /*decltype(_impl_.raw_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ViaLayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ViaLayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ViaLayerDefaultTypeInternal() {}
  union {
    ViaLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ViaLayerDefaultTypeInternal _ViaLayer_default_instance_;
PROTOBUF_CONSTEXPR PrimitiveLayer::PrimitiveLayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pitches_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PrimitiveLayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PrimitiveLayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PrimitiveLayerDefaultTypeInternal() {}
  union {
    PrimitiveLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrimitiveLayerDefaultTypeInternal _PrimitiveLayer_default_instance_;
PROTOBUF_CONSTEXPR TrackSpec_TrackEntry::TrackSpec_TrackEntry(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.width_)*/int64_t{0}
  , /*decltype(_impl_.ttype_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TrackSpec_TrackEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrackSpec_TrackEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrackSpec_TrackEntryDefaultTypeInternal() {}
  union {
    TrackSpec_TrackEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrackSpec_TrackEntryDefaultTypeInternal _TrackSpec_TrackEntry_default_instance_;
PROTOBUF_CONSTEXPR TrackSpec_Repeat::TrackSpec_Repeat(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entries_)*/{}
  , /*decltype(_impl_.nrep_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TrackSpec_RepeatDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrackSpec_RepeatDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrackSpec_RepeatDefaultTypeInternal() {}
  union {
    TrackSpec_Repeat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrackSpec_RepeatDefaultTypeInternal _TrackSpec_Repeat_default_instance_;
PROTOBUF_CONSTEXPR TrackSpec::TrackSpec(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.spec_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TrackSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrackSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrackSpecDefaultTypeInternal() {}
  union {
    TrackSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrackSpecDefaultTypeInternal _TrackSpec_default_instance_;
PROTOBUF_CONSTEXPR Xy::Xy(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/int64_t{0}
  , /*decltype(_impl_.y_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct XyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR XyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~XyDefaultTypeInternal() {}
  union {
    Xy _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XyDefaultTypeInternal _Xy_default_instance_;
}  // namespace tetris
}  // namespace vlsir
static ::_pb::Metadata file_level_metadata_layout_2ftetris_2eproto[24];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_layout_2ftetris_2eproto[5];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_layout_2ftetris_2eproto = nullptr;

const uint32_t TableStruct_layout_2ftetris_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Library, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Library, _impl_.domain_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Library, _impl_.cells_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Library, _impl_.author_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, _impl_.interface_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, _impl_.module_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, _impl_.abstract_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Cell, _impl_.layout_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, _impl_.outline_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, _impl_.instances_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, _impl_.assignments_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Layout, _impl_.cuts_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Assign, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Assign, _impl_.net_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Assign, _impl_.at_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackCross, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackCross, _impl_.track_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackCross, _impl_.cross_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackRef, _impl_.layer_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackRef, _impl_.track_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Outline, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Outline, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Outline, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Outline, _impl_.metals_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Abstract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Abstract, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Abstract, _impl_.outline_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Abstract, _impl_.ports_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_EdgePort, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_EdgePort, _impl_.track_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_EdgePort, _impl_.side_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopEdgePort, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopEdgePort, _impl_.track_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopEdgePort, _impl_.side_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopEdgePort, _impl_.into_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopInner, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort_ZTopInner, _impl_.locs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort, _impl_.net_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::AbstractPort, _impl_.kind_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, _impl_.cell_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, _impl_.loc_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, _impl_.reflect_horiz_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Instance, _impl_.reflect_vert_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Place, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Place, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Place, _impl_.place_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::RelPlace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, _impl_.units_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, _impl_.prim_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, _impl_.metals_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, _impl_.vias_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Stack, _impl_.boundary_layer_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::LayerEnum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::LayerEnum, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::LayerEnum, _impl_.index_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, _impl_.dir_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, _impl_.cutsize_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, _impl_.entries_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, _impl_.offset_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, _impl_.overlap_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, _impl_.flip_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, _impl_.prim_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::MetalLayer, _impl_.raw_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, _impl_.top_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, _impl_.bot_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::ViaLayer, _impl_.raw_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::PrimitiveLayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::PrimitiveLayer, _impl_.pitches_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_TrackEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_TrackEntry, _impl_.ttype_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_TrackEntry, _impl_.width_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_Repeat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_Repeat, _impl_.entries_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec_Repeat, _impl_.nrep_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::TrackSpec, _impl_.spec_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Xy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Xy, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::vlsir::tetris::Xy, _impl_.y_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::vlsir::tetris::Library)},
  { 9, -1, -1, sizeof(::vlsir::tetris::Cell)},
  { 20, -1, -1, sizeof(::vlsir::tetris::Layout)},
  { 31, -1, -1, sizeof(::vlsir::tetris::Assign)},
  { 39, -1, -1, sizeof(::vlsir::tetris::TrackCross)},
  { 47, -1, -1, sizeof(::vlsir::tetris::TrackRef)},
  { 55, -1, -1, sizeof(::vlsir::tetris::Outline)},
  { 64, -1, -1, sizeof(::vlsir::tetris::Abstract)},
  { 73, -1, -1, sizeof(::vlsir::tetris::AbstractPort_EdgePort)},
  { 81, -1, -1, sizeof(::vlsir::tetris::AbstractPort_ZTopEdgePort)},
  { 90, -1, -1, sizeof(::vlsir::tetris::AbstractPort_ZTopInner)},
  { 97, -1, -1, sizeof(::vlsir::tetris::AbstractPort)},
  { 108, -1, -1, sizeof(::vlsir::tetris::Instance)},
  { 119, -1, -1, sizeof(::vlsir::tetris::Place)},
  { 128, -1, -1, sizeof(::vlsir::tetris::RelPlace)},
  { 134, -1, -1, sizeof(::vlsir::tetris::Stack)},
  { 145, -1, -1, sizeof(::vlsir::tetris::LayerEnum)},
  { 153, -1, -1, sizeof(::vlsir::tetris::MetalLayer)},
  { 168, -1, -1, sizeof(::vlsir::tetris::ViaLayer)},
  { 179, -1, -1, sizeof(::vlsir::tetris::PrimitiveLayer)},
  { 186, -1, -1, sizeof(::vlsir::tetris::TrackSpec_TrackEntry)},
  { 194, -1, -1, sizeof(::vlsir::tetris::TrackSpec_Repeat)},
  { 202, -1, -1, sizeof(::vlsir::tetris::TrackSpec)},
  { 211, -1, -1, sizeof(::vlsir::tetris::Xy)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::vlsir::tetris::_Library_default_instance_._instance,
  &::vlsir::tetris::_Cell_default_instance_._instance,
  &::vlsir::tetris::_Layout_default_instance_._instance,
  &::vlsir::tetris::_Assign_default_instance_._instance,
  &::vlsir::tetris::_TrackCross_default_instance_._instance,
  &::vlsir::tetris::_TrackRef_default_instance_._instance,
  &::vlsir::tetris::_Outline_default_instance_._instance,
  &::vlsir::tetris::_Abstract_default_instance_._instance,
  &::vlsir::tetris::_AbstractPort_EdgePort_default_instance_._instance,
  &::vlsir::tetris::_AbstractPort_ZTopEdgePort_default_instance_._instance,
  &::vlsir::tetris::_AbstractPort_ZTopInner_default_instance_._instance,
  &::vlsir::tetris::_AbstractPort_default_instance_._instance,
  &::vlsir::tetris::_Instance_default_instance_._instance,
  &::vlsir::tetris::_Place_default_instance_._instance,
  &::vlsir::tetris::_RelPlace_default_instance_._instance,
  &::vlsir::tetris::_Stack_default_instance_._instance,
  &::vlsir::tetris::_LayerEnum_default_instance_._instance,
  &::vlsir::tetris::_MetalLayer_default_instance_._instance,
  &::vlsir::tetris::_ViaLayer_default_instance_._instance,
  &::vlsir::tetris::_PrimitiveLayer_default_instance_._instance,
  &::vlsir::tetris::_TrackSpec_TrackEntry_default_instance_._instance,
  &::vlsir::tetris::_TrackSpec_Repeat_default_instance_._instance,
  &::vlsir::tetris::_TrackSpec_default_instance_._instance,
  &::vlsir::tetris::_Xy_default_instance_._instance,
};

const char descriptor_table_protodef_layout_2ftetris_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023layout/tetris.proto\022\014vlsir.tetris\032\013uti"
  "ls.proto\032\020layout/raw.proto\032\rcircuit.prot"
  "o\"i\n\007Library\022\016\n\006domain\030\001 \001(\t\022!\n\005cells\030\n "
  "\003(\0132\022.vlsir.tetris.Cell\022+\n\006author\030\024 \001(\0132"
  "\033.vlsir.utils.AuthorMetadata\"\270\001\n\004Cell\022\014\n"
  "\004name\030\001 \001(\t\022+\n\tinterface\030\n \001(\0132\030.vlsir.c"
  "ircuit.Interface\022%\n\006module\030\013 \001(\0132\025.vlsir"
  ".circuit.Module\022(\n\010abstract\030\014 \001(\0132\026.vlsi"
  "r.tetris.Abstract\022$\n\006layout\030\r \001(\0132\024.vlsi"
  "r.tetris.Layout\"\274\001\n\006Layout\022\014\n\004name\030\001 \001(\t"
  "\022&\n\007outline\030\n \001(\0132\025.vlsir.tetris.Outline"
  "\022)\n\tinstances\030\024 \003(\0132\026.vlsir.tetris.Insta"
  "nce\022)\n\013assignments\030\025 \003(\0132\024.vlsir.tetris."
  "Assign\022&\n\004cuts\030\026 \003(\0132\030.vlsir.tetris.Trac"
  "kCross\";\n\006Assign\022\013\n\003net\030\001 \001(\t\022$\n\002at\030\002 \001("
  "\0132\030.vlsir.tetris.TrackCross\"Z\n\nTrackCros"
  "s\022%\n\005track\030\001 \001(\0132\026.vlsir.tetris.TrackRef"
  "\022%\n\005cross\030\002 \001(\0132\026.vlsir.tetris.TrackRef\""
  "(\n\010TrackRef\022\r\n\005layer\030\001 \001(\003\022\r\n\005track\030\002 \001("
  "\003\"/\n\007Outline\022\t\n\001x\030\001 \003(\003\022\t\n\001y\030\002 \003(\003\022\016\n\006me"
  "tals\030\003 \001(\003\"k\n\010Abstract\022\014\n\004name\030\001 \001(\t\022&\n\007"
  "outline\030\n \001(\0132\025.vlsir.tetris.Outline\022)\n\005"
  "ports\030\024 \003(\0132\032.vlsir.tetris.AbstractPort\""
  "\227\004\n\014AbstractPort\022\013\n\003net\030\001 \001(\t\0223\n\004edge\030\n "
  "\001(\0132#.vlsir.tetris.AbstractPort.EdgePort"
  "H\000\022<\n\tztop_edge\030\013 \001(\0132\'.vlsir.tetris.Abs"
  "tractPort.ZTopEdgePortH\000\022:\n\nztop_inner\030\014"
  " \001(\0132$.vlsir.tetris.AbstractPort.ZTopInn"
  "erH\000\032d\n\010EdgePort\022%\n\005track\030\001 \001(\0132\026.vlsir."
  "tetris.TrackRef\0221\n\004side\030\002 \001(\0162#.vlsir.te"
  "tris.AbstractPort.PortSide\032v\n\014ZTopEdgePo"
  "rt\022\r\n\005track\030\001 \001(\003\0221\n\004side\030\002 \001(\0162#.vlsir."
  "tetris.AbstractPort.PortSide\022$\n\004into\030\003 \001"
  "(\0132\026.vlsir.tetris.TrackRef\0323\n\tZTopInner\022"
  "&\n\004locs\030\001 \003(\0132\030.vlsir.tetris.TrackCross\""
  "0\n\010PortSide\022\022\n\016BOTTOM_OR_LEFT\020\000\022\020\n\014TOP_O"
  "R_RIGHT\020\001B\006\n\004kind\"\215\001\n\010Instance\022\014\n\004name\030\001"
  " \001(\t\022$\n\004cell\030\003 \001(\0132\026.vlsir.utils.Referen"
  "ce\022 \n\003loc\030\004 \001(\0132\023.vlsir.tetris.Place\022\025\n\r"
  "reflect_horiz\030\006 \001(\010\022\024\n\014reflect_vert\030\007 \001("
  "\010\"X\n\005Place\022\037\n\003abs\030\001 \001(\0132\020.vlsir.raw.Poin"
  "tH\000\022%\n\003rel\030\002 \001(\0132\026.vlsir.tetris.RelPlace"
  "H\000B\007\n\005place\"\n\n\010RelPlace\"\316\001\n\005Stack\022\037\n\005uni"
  "ts\030\001 \001(\0162\020.vlsir.raw.Units\022*\n\004prim\030\002 \001(\013"
  "2\034.vlsir.tetris.PrimitiveLayer\022(\n\006metals"
  "\030\003 \003(\0132\030.vlsir.tetris.MetalLayer\022$\n\004vias"
  "\030\004 \003(\0132\026.vlsir.tetris.ViaLayer\022(\n\016bounda"
  "ry_layer\030\013 \001(\0132\020.vlsir.raw.Layer\"{\n\tLaye"
  "rEnum\022/\n\004type\030\001 \001(\0162!.vlsir.tetris.Layer"
  "Enum.LayerType\022\r\n\005index\030\002 \001(\003\".\n\tLayerTy"
  "pe\022\r\n\tPRIMITIVE\020\000\022\t\n\005METAL\020\001\022\007\n\003VIA\020\002\"\321\002"
  "\n\nMetalLayer\022\014\n\004name\030\001 \001(\t\022)\n\003dir\030\002 \001(\0162"
  "\034.vlsir.tetris.MetalLayer.Dir\022\017\n\007cutsize"
  "\030\003 \001(\003\022(\n\007entries\030\004 \003(\0132\027.vlsir.tetris.T"
  "rackSpec\022\016\n\006offset\030\005 \001(\003\022\017\n\007overlap\030\006 \001("
  "\003\022\014\n\004flip\030\007 \001(\010\0224\n\004prim\030\010 \001(\0162&.vlsir.te"
  "tris.MetalLayer.PrimitiveMode\022\035\n\003raw\030\013 \001"
  "(\0132\020.vlsir.raw.Layer\"\032\n\003Dir\022\t\n\005HORIZ\020\000\022\010"
  "\n\004VERT\020\001\"/\n\rPrimitiveMode\022\010\n\004PRIM\020\000\022\t\n\005S"
  "PLIT\020\001\022\t\n\005STACK\020\002\"\243\001\n\010ViaLayer\022\014\n\004name\030\001"
  " \001(\t\022$\n\003top\030\002 \001(\0132\027.vlsir.tetris.LayerEn"
  "um\022$\n\003bot\030\003 \001(\0132\027.vlsir.tetris.LayerEnum"
  "\022\036\n\004size\030\004 \001(\0132\020.vlsir.tetris.Xy\022\035\n\003raw\030"
  "\013 \001(\0132\020.vlsir.raw.Layer\"3\n\016PrimitiveLaye"
  "r\022!\n\007pitches\030\001 \001(\0132\020.vlsir.tetris.Xy\"\316\002\n"
  "\tTrackSpec\0223\n\005entry\030\001 \001(\0132\".vlsir.tetris"
  ".TrackSpec.TrackEntryH\000\0220\n\006repeat\030\002 \001(\0132"
  "\036.vlsir.tetris.TrackSpec.RepeatH\000\032\204\001\n\nTr"
  "ackEntry\022;\n\005ttype\030\001 \001(\0162,.vlsir.tetris.T"
  "rackSpec.TrackEntry.TrackType\022\r\n\005width\030\002"
  " \001(\003\"*\n\tTrackType\022\007\n\003GAP\020\000\022\n\n\006SIGNAL\020\001\022\010"
  "\n\004RAIL\020\002\032K\n\006Repeat\0223\n\007entries\030\001 \003(\0132\".vl"
  "sir.tetris.TrackSpec.TrackEntry\022\014\n\004nrep\030"
  "\002 \001(\003B\006\n\004spec\"\032\n\002Xy\022\t\n\001x\030\001 \001(\003\022\t\n\001y\030\002 \001("
  "\003b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_layout_2ftetris_2eproto_deps[3] = {
  &::descriptor_table_circuit_2eproto,
  &::descriptor_table_layout_2fraw_2eproto,
  &::descriptor_table_utils_2eproto,
};
static ::_pbi::once_flag descriptor_table_layout_2ftetris_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_layout_2ftetris_2eproto = {
    false, false, 2969, descriptor_table_protodef_layout_2ftetris_2eproto,
    "layout/tetris.proto",
    &descriptor_table_layout_2ftetris_2eproto_once, descriptor_table_layout_2ftetris_2eproto_deps, 3, 24,
    schemas, file_default_instances, TableStruct_layout_2ftetris_2eproto::offsets,
    file_level_metadata_layout_2ftetris_2eproto, file_level_enum_descriptors_layout_2ftetris_2eproto,
    file_level_service_descriptors_layout_2ftetris_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_layout_2ftetris_2eproto_getter() {
  return &descriptor_table_layout_2ftetris_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_layout_2ftetris_2eproto(&descriptor_table_layout_2ftetris_2eproto);
namespace vlsir {
namespace tetris {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AbstractPort_PortSide_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_layout_2ftetris_2eproto);
  return file_level_enum_descriptors_layout_2ftetris_2eproto[0];
}
bool AbstractPort_PortSide_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AbstractPort_PortSide AbstractPort::BOTTOM_OR_LEFT;
constexpr AbstractPort_PortSide AbstractPort::TOP_OR_RIGHT;
constexpr AbstractPort_PortSide AbstractPort::PortSide_MIN;
constexpr AbstractPort_PortSide AbstractPort::PortSide_MAX;
constexpr int AbstractPort::PortSide_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LayerEnum_LayerType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_layout_2ftetris_2eproto);
  return file_level_enum_descriptors_layout_2ftetris_2eproto[1];
}
bool LayerEnum_LayerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LayerEnum_LayerType LayerEnum::PRIMITIVE;
constexpr LayerEnum_LayerType LayerEnum::METAL;
constexpr LayerEnum_LayerType LayerEnum::VIA;
constexpr LayerEnum_LayerType LayerEnum::LayerType_MIN;
constexpr LayerEnum_LayerType LayerEnum::LayerType_MAX;
constexpr int LayerEnum::LayerType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MetalLayer_Dir_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_layout_2ftetris_2eproto);
  return file_level_enum_descriptors_layout_2ftetris_2eproto[2];
}
bool MetalLayer_Dir_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MetalLayer_Dir MetalLayer::HORIZ;
constexpr MetalLayer_Dir MetalLayer::VERT;
constexpr MetalLayer_Dir MetalLayer::Dir_MIN;
constexpr MetalLayer_Dir MetalLayer::Dir_MAX;
constexpr int MetalLayer::Dir_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MetalLayer_PrimitiveMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_layout_2ftetris_2eproto);
  return file_level_enum_descriptors_layout_2ftetris_2eproto[3];
}
bool MetalLayer_PrimitiveMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr MetalLayer_PrimitiveMode MetalLayer::PRIM;
constexpr MetalLayer_PrimitiveMode MetalLayer::SPLIT;
constexpr MetalLayer_PrimitiveMode MetalLayer::STACK;
constexpr MetalLayer_PrimitiveMode MetalLayer::PrimitiveMode_MIN;
constexpr MetalLayer_PrimitiveMode MetalLayer::PrimitiveMode_MAX;
constexpr int MetalLayer::PrimitiveMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackSpec_TrackEntry_TrackType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_layout_2ftetris_2eproto);
  return file_level_enum_descriptors_layout_2ftetris_2eproto[4];
}
bool TrackSpec_TrackEntry_TrackType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::GAP;
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::SIGNAL;
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::RAIL;
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::TrackType_MIN;
constexpr TrackSpec_TrackEntry_TrackType TrackSpec_TrackEntry::TrackType_MAX;
constexpr int TrackSpec_TrackEntry::TrackType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Library::_Internal {
 public:
  static const ::vlsir::utils::AuthorMetadata& author(const Library* msg);
};

const ::vlsir::utils::AuthorMetadata&
Library::_Internal::author(const Library* msg) {
  return *msg->_impl_.author_;
}
void Library::clear_author() {
  if (GetArenaForAllocation() == nullptr && _impl_.author_ != nullptr) {
    delete _impl_.author_;
  }
  _impl_.author_ = nullptr;
}
Library::Library(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Library)
}
Library::Library(const Library& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Library* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cells_){from._impl_.cells_}
    , decltype(_impl_.domain_){}
    , decltype(_impl_.author_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_domain().empty()) {
    _this->_impl_.domain_.Set(from._internal_domain(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_author()) {
    _this->_impl_.author_ = new ::vlsir::utils::AuthorMetadata(*from._impl_.author_);
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Library)
}

inline void Library::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.cells_){arena}
    , decltype(_impl_.domain_){}
    , decltype(_impl_.author_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.domain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Library::~Library() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Library)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Library::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cells_.~RepeatedPtrField();
  _impl_.domain_.Destroy();
  if (this != internal_default_instance()) delete _impl_.author_;
}

void Library::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Library::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Library)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cells_.Clear();
  _impl_.domain_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.author_ != nullptr) {
    delete _impl_.author_;
  }
  _impl_.author_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Library::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string domain = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_domain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.tetris.Library.domain"));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.Cell cells = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cells(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.utils.AuthorMetadata author = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_author(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Library::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Library)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string domain = 1;
  if (!this->_internal_domain().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_domain().data(), static_cast<int>(this->_internal_domain().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Library.domain");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_domain(), target);
  }

  // repeated .vlsir.tetris.Cell cells = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cells_size()); i < n; i++) {
    const auto& repfield = this->_internal_cells(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .vlsir.utils.AuthorMetadata author = 20;
  if (this->_internal_has_author()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::author(this),
        _Internal::author(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Library)
  return target;
}

size_t Library::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Library)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.Cell cells = 10;
  total_size += 1UL * this->_internal_cells_size();
  for (const auto& msg : this->_impl_.cells_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string domain = 1;
  if (!this->_internal_domain().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_domain());
  }

  // .vlsir.utils.AuthorMetadata author = 20;
  if (this->_internal_has_author()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.author_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Library::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Library::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Library::GetClassData() const { return &_class_data_; }


void Library::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Library*>(&to_msg);
  auto& from = static_cast<const Library&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Library)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.cells_.MergeFrom(from._impl_.cells_);
  if (!from._internal_domain().empty()) {
    _this->_internal_set_domain(from._internal_domain());
  }
  if (from._internal_has_author()) {
    _this->_internal_mutable_author()->::vlsir::utils::AuthorMetadata::MergeFrom(
        from._internal_author());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Library::CopyFrom(const Library& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Library)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Library::IsInitialized() const {
  return true;
}

void Library::InternalSwap(Library* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.cells_.InternalSwap(&other->_impl_.cells_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.domain_, lhs_arena,
      &other->_impl_.domain_, rhs_arena
  );
  swap(_impl_.author_, other->_impl_.author_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Library::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[0]);
}

// ===================================================================

class Cell::_Internal {
 public:
  static const ::vlsir::circuit::Interface& interface(const Cell* msg);
  static const ::vlsir::circuit::Module& module(const Cell* msg);
  static const ::vlsir::tetris::Abstract& abstract(const Cell* msg);
  static const ::vlsir::tetris::Layout& layout(const Cell* msg);
};

const ::vlsir::circuit::Interface&
Cell::_Internal::interface(const Cell* msg) {
  return *msg->_impl_.interface_;
}
const ::vlsir::circuit::Module&
Cell::_Internal::module(const Cell* msg) {
  return *msg->_impl_.module_;
}
const ::vlsir::tetris::Abstract&
Cell::_Internal::abstract(const Cell* msg) {
  return *msg->_impl_.abstract_;
}
const ::vlsir::tetris::Layout&
Cell::_Internal::layout(const Cell* msg) {
  return *msg->_impl_.layout_;
}
void Cell::clear_interface() {
  if (GetArenaForAllocation() == nullptr && _impl_.interface_ != nullptr) {
    delete _impl_.interface_;
  }
  _impl_.interface_ = nullptr;
}
void Cell::clear_module() {
  if (GetArenaForAllocation() == nullptr && _impl_.module_ != nullptr) {
    delete _impl_.module_;
  }
  _impl_.module_ = nullptr;
}
Cell::Cell(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Cell)
}
Cell::Cell(const Cell& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Cell* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.interface_){nullptr}
    , decltype(_impl_.module_){nullptr}
    , decltype(_impl_.abstract_){nullptr}
    , decltype(_impl_.layout_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_interface()) {
    _this->_impl_.interface_ = new ::vlsir::circuit::Interface(*from._impl_.interface_);
  }
  if (from._internal_has_module()) {
    _this->_impl_.module_ = new ::vlsir::circuit::Module(*from._impl_.module_);
  }
  if (from._internal_has_abstract()) {
    _this->_impl_.abstract_ = new ::vlsir::tetris::Abstract(*from._impl_.abstract_);
  }
  if (from._internal_has_layout()) {
    _this->_impl_.layout_ = new ::vlsir::tetris::Layout(*from._impl_.layout_);
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Cell)
}

inline void Cell::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.interface_){nullptr}
    , decltype(_impl_.module_){nullptr}
    , decltype(_impl_.abstract_){nullptr}
    , decltype(_impl_.layout_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Cell::~Cell() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Cell)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Cell::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.interface_;
  if (this != internal_default_instance()) delete _impl_.module_;
  if (this != internal_default_instance()) delete _impl_.abstract_;
  if (this != internal_default_instance()) delete _impl_.layout_;
}

void Cell::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Cell::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Cell)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.interface_ != nullptr) {
    delete _impl_.interface_;
  }
  _impl_.interface_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.module_ != nullptr) {
    delete _impl_.module_;
  }
  _impl_.module_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.abstract_ != nullptr) {
    delete _impl_.abstract_;
  }
  _impl_.abstract_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.layout_ != nullptr) {
    delete _impl_.layout_;
  }
  _impl_.layout_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Cell::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.tetris.Cell.name"));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.circuit.Interface interface = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_interface(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.circuit.Module module = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_module(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.Abstract abstract = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_abstract(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.Layout layout = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_layout(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Cell::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Cell)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Cell.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.circuit.Interface interface = 10;
  if (this->_internal_has_interface()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::interface(this),
        _Internal::interface(this).GetCachedSize(), target, stream);
  }

  // .vlsir.circuit.Module module = 11;
  if (this->_internal_has_module()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::module(this),
        _Internal::module(this).GetCachedSize(), target, stream);
  }

  // .vlsir.tetris.Abstract abstract = 12;
  if (this->_internal_has_abstract()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::abstract(this),
        _Internal::abstract(this).GetCachedSize(), target, stream);
  }

  // .vlsir.tetris.Layout layout = 13;
  if (this->_internal_has_layout()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::layout(this),
        _Internal::layout(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Cell)
  return target;
}

size_t Cell::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Cell)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.circuit.Interface interface = 10;
  if (this->_internal_has_interface()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.interface_);
  }

  // .vlsir.circuit.Module module = 11;
  if (this->_internal_has_module()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.module_);
  }

  // .vlsir.tetris.Abstract abstract = 12;
  if (this->_internal_has_abstract()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.abstract_);
  }

  // .vlsir.tetris.Layout layout = 13;
  if (this->_internal_has_layout()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.layout_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Cell::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Cell::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Cell::GetClassData() const { return &_class_data_; }


void Cell::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Cell*>(&to_msg);
  auto& from = static_cast<const Cell&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Cell)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_interface()) {
    _this->_internal_mutable_interface()->::vlsir::circuit::Interface::MergeFrom(
        from._internal_interface());
  }
  if (from._internal_has_module()) {
    _this->_internal_mutable_module()->::vlsir::circuit::Module::MergeFrom(
        from._internal_module());
  }
  if (from._internal_has_abstract()) {
    _this->_internal_mutable_abstract()->::vlsir::tetris::Abstract::MergeFrom(
        from._internal_abstract());
  }
  if (from._internal_has_layout()) {
    _this->_internal_mutable_layout()->::vlsir::tetris::Layout::MergeFrom(
        from._internal_layout());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Cell::CopyFrom(const Cell& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Cell)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cell::IsInitialized() const {
  return true;
}

void Cell::InternalSwap(Cell* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Cell, _impl_.layout_)
      + sizeof(Cell::_impl_.layout_)
      - PROTOBUF_FIELD_OFFSET(Cell, _impl_.interface_)>(
          reinterpret_cast<char*>(&_impl_.interface_),
          reinterpret_cast<char*>(&other->_impl_.interface_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Cell::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[1]);
}

// ===================================================================

class Layout::_Internal {
 public:
  static const ::vlsir::tetris::Outline& outline(const Layout* msg);
};

const ::vlsir::tetris::Outline&
Layout::_Internal::outline(const Layout* msg) {
  return *msg->_impl_.outline_;
}
Layout::Layout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Layout)
}
Layout::Layout(const Layout& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Layout* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.instances_){from._impl_.instances_}
    , decltype(_impl_.assignments_){from._impl_.assignments_}
    , decltype(_impl_.cuts_){from._impl_.cuts_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.outline_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_outline()) {
    _this->_impl_.outline_ = new ::vlsir::tetris::Outline(*from._impl_.outline_);
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Layout)
}

inline void Layout::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.instances_){arena}
    , decltype(_impl_.assignments_){arena}
    , decltype(_impl_.cuts_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.outline_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Layout::~Layout() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Layout)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Layout::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.instances_.~RepeatedPtrField();
  _impl_.assignments_.~RepeatedPtrField();
  _impl_.cuts_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.outline_;
}

void Layout::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Layout::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Layout)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.instances_.Clear();
  _impl_.assignments_.Clear();
  _impl_.cuts_.Clear();
  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.outline_ != nullptr) {
    delete _impl_.outline_;
  }
  _impl_.outline_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Layout::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.tetris.Layout.name"));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.Outline outline = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_outline(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.Instance instances = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_instances(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.Assign assignments = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_assignments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.TrackCross cuts = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_cuts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Layout::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Layout)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Layout.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.tetris.Outline outline = 10;
  if (this->_internal_has_outline()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::outline(this),
        _Internal::outline(this).GetCachedSize(), target, stream);
  }

  // repeated .vlsir.tetris.Instance instances = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_instances_size()); i < n; i++) {
    const auto& repfield = this->_internal_instances(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .vlsir.tetris.Assign assignments = 21;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_assignments_size()); i < n; i++) {
    const auto& repfield = this->_internal_assignments(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(21, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .vlsir.tetris.TrackCross cuts = 22;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cuts_size()); i < n; i++) {
    const auto& repfield = this->_internal_cuts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Layout)
  return target;
}

size_t Layout::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Layout)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.Instance instances = 20;
  total_size += 2UL * this->_internal_instances_size();
  for (const auto& msg : this->_impl_.instances_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.tetris.Assign assignments = 21;
  total_size += 2UL * this->_internal_assignments_size();
  for (const auto& msg : this->_impl_.assignments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.tetris.TrackCross cuts = 22;
  total_size += 2UL * this->_internal_cuts_size();
  for (const auto& msg : this->_impl_.cuts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.tetris.Outline outline = 10;
  if (this->_internal_has_outline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.outline_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Layout::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Layout::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Layout::GetClassData() const { return &_class_data_; }


void Layout::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Layout*>(&to_msg);
  auto& from = static_cast<const Layout&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Layout)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.instances_.MergeFrom(from._impl_.instances_);
  _this->_impl_.assignments_.MergeFrom(from._impl_.assignments_);
  _this->_impl_.cuts_.MergeFrom(from._impl_.cuts_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_outline()) {
    _this->_internal_mutable_outline()->::vlsir::tetris::Outline::MergeFrom(
        from._internal_outline());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Layout::CopyFrom(const Layout& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Layout)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Layout::IsInitialized() const {
  return true;
}

void Layout::InternalSwap(Layout* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.instances_.InternalSwap(&other->_impl_.instances_);
  _impl_.assignments_.InternalSwap(&other->_impl_.assignments_);
  _impl_.cuts_.InternalSwap(&other->_impl_.cuts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.outline_, other->_impl_.outline_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Layout::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[2]);
}

// ===================================================================

class Assign::_Internal {
 public:
  static const ::vlsir::tetris::TrackCross& at(const Assign* msg);
};

const ::vlsir::tetris::TrackCross&
Assign::_Internal::at(const Assign* msg) {
  return *msg->_impl_.at_;
}
Assign::Assign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Assign)
}
Assign::Assign(const Assign& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Assign* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.net_){}
    , decltype(_impl_.at_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.net_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_net().empty()) {
    _this->_impl_.net_.Set(from._internal_net(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_at()) {
    _this->_impl_.at_ = new ::vlsir::tetris::TrackCross(*from._impl_.at_);
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Assign)
}

inline void Assign::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.net_){}
    , decltype(_impl_.at_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.net_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Assign::~Assign() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Assign)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Assign::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.net_.Destroy();
  if (this != internal_default_instance()) delete _impl_.at_;
}

void Assign::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Assign::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Assign)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.net_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.at_ != nullptr) {
    delete _impl_.at_;
  }
  _impl_.at_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Assign::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string net = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_net();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.tetris.Assign.net"));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.TrackCross at = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_at(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Assign::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Assign)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string net = 1;
  if (!this->_internal_net().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_net().data(), static_cast<int>(this->_internal_net().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Assign.net");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_net(), target);
  }

  // .vlsir.tetris.TrackCross at = 2;
  if (this->_internal_has_at()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::at(this),
        _Internal::at(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Assign)
  return target;
}

size_t Assign::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Assign)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string net = 1;
  if (!this->_internal_net().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_net());
  }

  // .vlsir.tetris.TrackCross at = 2;
  if (this->_internal_has_at()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.at_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Assign::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Assign::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Assign::GetClassData() const { return &_class_data_; }


void Assign::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Assign*>(&to_msg);
  auto& from = static_cast<const Assign&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Assign)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_net().empty()) {
    _this->_internal_set_net(from._internal_net());
  }
  if (from._internal_has_at()) {
    _this->_internal_mutable_at()->::vlsir::tetris::TrackCross::MergeFrom(
        from._internal_at());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Assign::CopyFrom(const Assign& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Assign)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Assign::IsInitialized() const {
  return true;
}

void Assign::InternalSwap(Assign* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.net_, lhs_arena,
      &other->_impl_.net_, rhs_arena
  );
  swap(_impl_.at_, other->_impl_.at_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Assign::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[3]);
}

// ===================================================================

class TrackCross::_Internal {
 public:
  static const ::vlsir::tetris::TrackRef& track(const TrackCross* msg);
  static const ::vlsir::tetris::TrackRef& cross(const TrackCross* msg);
};

const ::vlsir::tetris::TrackRef&
TrackCross::_Internal::track(const TrackCross* msg) {
  return *msg->_impl_.track_;
}
const ::vlsir::tetris::TrackRef&
TrackCross::_Internal::cross(const TrackCross* msg) {
  return *msg->_impl_.cross_;
}
TrackCross::TrackCross(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackCross)
}
TrackCross::TrackCross(const TrackCross& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TrackCross* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.track_){nullptr}
    , decltype(_impl_.cross_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_track()) {
    _this->_impl_.track_ = new ::vlsir::tetris::TrackRef(*from._impl_.track_);
  }
  if (from._internal_has_cross()) {
    _this->_impl_.cross_ = new ::vlsir::tetris::TrackRef(*from._impl_.cross_);
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackCross)
}

inline void TrackCross::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.track_){nullptr}
    , decltype(_impl_.cross_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TrackCross::~TrackCross() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackCross)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrackCross::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.track_;
  if (this != internal_default_instance()) delete _impl_.cross_;
}

void TrackCross::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrackCross::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackCross)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.track_ != nullptr) {
    delete _impl_.track_;
  }
  _impl_.track_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.cross_ != nullptr) {
    delete _impl_.cross_;
  }
  _impl_.cross_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackCross::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.tetris.TrackRef track = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_track(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.TrackRef cross = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_cross(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackCross::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackCross)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef track = 1;
  if (this->_internal_has_track()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::track(this),
        _Internal::track(this).GetCachedSize(), target, stream);
  }

  // .vlsir.tetris.TrackRef cross = 2;
  if (this->_internal_has_cross()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::cross(this),
        _Internal::cross(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackCross)
  return target;
}

size_t TrackCross::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackCross)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef track = 1;
  if (this->_internal_has_track()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.track_);
  }

  // .vlsir.tetris.TrackRef cross = 2;
  if (this->_internal_has_cross()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cross_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackCross::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TrackCross::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackCross::GetClassData() const { return &_class_data_; }


void TrackCross::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TrackCross*>(&to_msg);
  auto& from = static_cast<const TrackCross&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackCross)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_track()) {
    _this->_internal_mutable_track()->::vlsir::tetris::TrackRef::MergeFrom(
        from._internal_track());
  }
  if (from._internal_has_cross()) {
    _this->_internal_mutable_cross()->::vlsir::tetris::TrackRef::MergeFrom(
        from._internal_cross());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackCross::CopyFrom(const TrackCross& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackCross)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackCross::IsInitialized() const {
  return true;
}

void TrackCross::InternalSwap(TrackCross* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackCross, _impl_.cross_)
      + sizeof(TrackCross::_impl_.cross_)
      - PROTOBUF_FIELD_OFFSET(TrackCross, _impl_.track_)>(
          reinterpret_cast<char*>(&_impl_.track_),
          reinterpret_cast<char*>(&other->_impl_.track_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackCross::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[4]);
}

// ===================================================================

class TrackRef::_Internal {
 public:
};

TrackRef::TrackRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackRef)
}
TrackRef::TrackRef(const TrackRef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TrackRef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.layer_){}
    , decltype(_impl_.track_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.layer_, &from._impl_.layer_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.track_) -
    reinterpret_cast<char*>(&_impl_.layer_)) + sizeof(_impl_.track_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackRef)
}

inline void TrackRef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.layer_){int64_t{0}}
    , decltype(_impl_.track_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TrackRef::~TrackRef() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackRef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrackRef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TrackRef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrackRef::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackRef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.layer_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.track_) -
      reinterpret_cast<char*>(&_impl_.layer_)) + sizeof(_impl_.track_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackRef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 layer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.layer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 track = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.track_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackRef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackRef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 layer = 1;
  if (this->_internal_layer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_layer(), target);
  }

  // int64 track = 2;
  if (this->_internal_track() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_track(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackRef)
  return target;
}

size_t TrackRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackRef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 layer = 1;
  if (this->_internal_layer() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_layer());
  }

  // int64 track = 2;
  if (this->_internal_track() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_track());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackRef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TrackRef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackRef::GetClassData() const { return &_class_data_; }


void TrackRef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TrackRef*>(&to_msg);
  auto& from = static_cast<const TrackRef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackRef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_layer() != 0) {
    _this->_internal_set_layer(from._internal_layer());
  }
  if (from._internal_track() != 0) {
    _this->_internal_set_track(from._internal_track());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackRef::CopyFrom(const TrackRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackRef::IsInitialized() const {
  return true;
}

void TrackRef::InternalSwap(TrackRef* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackRef, _impl_.track_)
      + sizeof(TrackRef::_impl_.track_)
      - PROTOBUF_FIELD_OFFSET(TrackRef, _impl_.layer_)>(
          reinterpret_cast<char*>(&_impl_.layer_),
          reinterpret_cast<char*>(&other->_impl_.layer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackRef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[5]);
}

// ===================================================================

class Outline::_Internal {
 public:
};

Outline::Outline(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Outline)
}
Outline::Outline(const Outline& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Outline* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){from._impl_.x_}
    , /*decltype(_impl_._x_cached_byte_size_)*/{0}
    , decltype(_impl_.y_){from._impl_.y_}
    , /*decltype(_impl_._y_cached_byte_size_)*/{0}
    , decltype(_impl_.metals_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.metals_ = from._impl_.metals_;
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Outline)
}

inline void Outline::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){arena}
    , /*decltype(_impl_._x_cached_byte_size_)*/{0}
    , decltype(_impl_.y_){arena}
    , /*decltype(_impl_._y_cached_byte_size_)*/{0}
    , decltype(_impl_.metals_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Outline::~Outline() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Outline)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Outline::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.x_.~RepeatedField();
  _impl_.y_.~RepeatedField();
}

void Outline::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Outline::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Outline)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.x_.Clear();
  _impl_.y_.Clear();
  _impl_.metals_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Outline::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_x(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_x(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_y(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_y(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 metals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.metals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Outline::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Outline)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 x = 1;
  {
    int byte_size = _impl_._x_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_x(), byte_size, target);
    }
  }

  // repeated int64 y = 2;
  {
    int byte_size = _impl_._y_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_y(), byte_size, target);
    }
  }

  // int64 metals = 3;
  if (this->_internal_metals() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_metals(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Outline)
  return target;
}

size_t Outline::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Outline)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 x = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.x_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._x_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 y = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.y_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._y_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int64 metals = 3;
  if (this->_internal_metals() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_metals());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Outline::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Outline::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Outline::GetClassData() const { return &_class_data_; }


void Outline::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Outline*>(&to_msg);
  auto& from = static_cast<const Outline&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Outline)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.x_.MergeFrom(from._impl_.x_);
  _this->_impl_.y_.MergeFrom(from._impl_.y_);
  if (from._internal_metals() != 0) {
    _this->_internal_set_metals(from._internal_metals());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Outline::CopyFrom(const Outline& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Outline)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Outline::IsInitialized() const {
  return true;
}

void Outline::InternalSwap(Outline* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.x_.InternalSwap(&other->_impl_.x_);
  _impl_.y_.InternalSwap(&other->_impl_.y_);
  swap(_impl_.metals_, other->_impl_.metals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Outline::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[6]);
}

// ===================================================================

class Abstract::_Internal {
 public:
  static const ::vlsir::tetris::Outline& outline(const Abstract* msg);
};

const ::vlsir::tetris::Outline&
Abstract::_Internal::outline(const Abstract* msg) {
  return *msg->_impl_.outline_;
}
Abstract::Abstract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Abstract)
}
Abstract::Abstract(const Abstract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Abstract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ports_){from._impl_.ports_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.outline_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_outline()) {
    _this->_impl_.outline_ = new ::vlsir::tetris::Outline(*from._impl_.outline_);
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Abstract)
}

inline void Abstract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ports_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.outline_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Abstract::~Abstract() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Abstract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Abstract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ports_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.outline_;
}

void Abstract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Abstract::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Abstract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ports_.Clear();
  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.outline_ != nullptr) {
    delete _impl_.outline_;
  }
  _impl_.outline_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Abstract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.tetris.Abstract.name"));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.Outline outline = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_outline(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.AbstractPort ports = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_ports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Abstract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Abstract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Abstract.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.tetris.Outline outline = 10;
  if (this->_internal_has_outline()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::outline(this),
        _Internal::outline(this).GetCachedSize(), target, stream);
  }

  // repeated .vlsir.tetris.AbstractPort ports = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ports_size()); i < n; i++) {
    const auto& repfield = this->_internal_ports(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Abstract)
  return target;
}

size_t Abstract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Abstract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.AbstractPort ports = 20;
  total_size += 2UL * this->_internal_ports_size();
  for (const auto& msg : this->_impl_.ports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.tetris.Outline outline = 10;
  if (this->_internal_has_outline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.outline_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Abstract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Abstract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Abstract::GetClassData() const { return &_class_data_; }


void Abstract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Abstract*>(&to_msg);
  auto& from = static_cast<const Abstract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Abstract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ports_.MergeFrom(from._impl_.ports_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_outline()) {
    _this->_internal_mutable_outline()->::vlsir::tetris::Outline::MergeFrom(
        from._internal_outline());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Abstract::CopyFrom(const Abstract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Abstract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Abstract::IsInitialized() const {
  return true;
}

void Abstract::InternalSwap(Abstract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ports_.InternalSwap(&other->_impl_.ports_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.outline_, other->_impl_.outline_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Abstract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[7]);
}

// ===================================================================

class AbstractPort_EdgePort::_Internal {
 public:
  static const ::vlsir::tetris::TrackRef& track(const AbstractPort_EdgePort* msg);
};

const ::vlsir::tetris::TrackRef&
AbstractPort_EdgePort::_Internal::track(const AbstractPort_EdgePort* msg) {
  return *msg->_impl_.track_;
}
AbstractPort_EdgePort::AbstractPort_EdgePort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.AbstractPort.EdgePort)
}
AbstractPort_EdgePort::AbstractPort_EdgePort(const AbstractPort_EdgePort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AbstractPort_EdgePort* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.track_){nullptr}
    , decltype(_impl_.side_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_track()) {
    _this->_impl_.track_ = new ::vlsir::tetris::TrackRef(*from._impl_.track_);
  }
  _this->_impl_.side_ = from._impl_.side_;
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.AbstractPort.EdgePort)
}

inline void AbstractPort_EdgePort::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.track_){nullptr}
    , decltype(_impl_.side_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AbstractPort_EdgePort::~AbstractPort_EdgePort() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.AbstractPort.EdgePort)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AbstractPort_EdgePort::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.track_;
}

void AbstractPort_EdgePort::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AbstractPort_EdgePort::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.AbstractPort.EdgePort)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.track_ != nullptr) {
    delete _impl_.track_;
  }
  _impl_.track_ = nullptr;
  _impl_.side_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AbstractPort_EdgePort::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.tetris.TrackRef track = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_track(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.PortSide side = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::vlsir::tetris::AbstractPort_PortSide>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AbstractPort_EdgePort::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.AbstractPort.EdgePort)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef track = 1;
  if (this->_internal_has_track()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::track(this),
        _Internal::track(this).GetCachedSize(), target, stream);
  }

  // .vlsir.tetris.AbstractPort.PortSide side = 2;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_side(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.AbstractPort.EdgePort)
  return target;
}

size_t AbstractPort_EdgePort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.AbstractPort.EdgePort)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef track = 1;
  if (this->_internal_has_track()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.track_);
  }

  // .vlsir.tetris.AbstractPort.PortSide side = 2;
  if (this->_internal_side() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AbstractPort_EdgePort::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AbstractPort_EdgePort::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AbstractPort_EdgePort::GetClassData() const { return &_class_data_; }


void AbstractPort_EdgePort::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AbstractPort_EdgePort*>(&to_msg);
  auto& from = static_cast<const AbstractPort_EdgePort&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.AbstractPort.EdgePort)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_track()) {
    _this->_internal_mutable_track()->::vlsir::tetris::TrackRef::MergeFrom(
        from._internal_track());
  }
  if (from._internal_side() != 0) {
    _this->_internal_set_side(from._internal_side());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AbstractPort_EdgePort::CopyFrom(const AbstractPort_EdgePort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.AbstractPort.EdgePort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbstractPort_EdgePort::IsInitialized() const {
  return true;
}

void AbstractPort_EdgePort::InternalSwap(AbstractPort_EdgePort* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AbstractPort_EdgePort, _impl_.side_)
      + sizeof(AbstractPort_EdgePort::_impl_.side_)
      - PROTOBUF_FIELD_OFFSET(AbstractPort_EdgePort, _impl_.track_)>(
          reinterpret_cast<char*>(&_impl_.track_),
          reinterpret_cast<char*>(&other->_impl_.track_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AbstractPort_EdgePort::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[8]);
}

// ===================================================================

class AbstractPort_ZTopEdgePort::_Internal {
 public:
  static const ::vlsir::tetris::TrackRef& into(const AbstractPort_ZTopEdgePort* msg);
};

const ::vlsir::tetris::TrackRef&
AbstractPort_ZTopEdgePort::_Internal::into(const AbstractPort_ZTopEdgePort* msg) {
  return *msg->_impl_.into_;
}
AbstractPort_ZTopEdgePort::AbstractPort_ZTopEdgePort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.AbstractPort.ZTopEdgePort)
}
AbstractPort_ZTopEdgePort::AbstractPort_ZTopEdgePort(const AbstractPort_ZTopEdgePort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AbstractPort_ZTopEdgePort* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.into_){nullptr}
    , decltype(_impl_.track_){}
    , decltype(_impl_.side_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_into()) {
    _this->_impl_.into_ = new ::vlsir::tetris::TrackRef(*from._impl_.into_);
  }
  ::memcpy(&_impl_.track_, &from._impl_.track_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.side_) -
    reinterpret_cast<char*>(&_impl_.track_)) + sizeof(_impl_.side_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.AbstractPort.ZTopEdgePort)
}

inline void AbstractPort_ZTopEdgePort::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.into_){nullptr}
    , decltype(_impl_.track_){int64_t{0}}
    , decltype(_impl_.side_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AbstractPort_ZTopEdgePort::~AbstractPort_ZTopEdgePort() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.AbstractPort.ZTopEdgePort)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AbstractPort_ZTopEdgePort::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.into_;
}

void AbstractPort_ZTopEdgePort::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AbstractPort_ZTopEdgePort::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.into_ != nullptr) {
    delete _impl_.into_;
  }
  _impl_.into_ = nullptr;
  ::memset(&_impl_.track_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.side_) -
      reinterpret_cast<char*>(&_impl_.track_)) + sizeof(_impl_.side_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AbstractPort_ZTopEdgePort::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 track = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.track_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.PortSide side = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_side(static_cast<::vlsir::tetris::AbstractPort_PortSide>(val));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.TrackRef into = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_into(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AbstractPort_ZTopEdgePort::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 track = 1;
  if (this->_internal_track() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_track(), target);
  }

  // .vlsir.tetris.AbstractPort.PortSide side = 2;
  if (this->_internal_side() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_side(), target);
  }

  // .vlsir.tetris.TrackRef into = 3;
  if (this->_internal_has_into()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::into(this),
        _Internal::into(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.AbstractPort.ZTopEdgePort)
  return target;
}

size_t AbstractPort_ZTopEdgePort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vlsir.tetris.TrackRef into = 3;
  if (this->_internal_has_into()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.into_);
  }

  // int64 track = 1;
  if (this->_internal_track() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_track());
  }

  // .vlsir.tetris.AbstractPort.PortSide side = 2;
  if (this->_internal_side() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_side());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AbstractPort_ZTopEdgePort::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AbstractPort_ZTopEdgePort::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AbstractPort_ZTopEdgePort::GetClassData() const { return &_class_data_; }


void AbstractPort_ZTopEdgePort::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AbstractPort_ZTopEdgePort*>(&to_msg);
  auto& from = static_cast<const AbstractPort_ZTopEdgePort&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_into()) {
    _this->_internal_mutable_into()->::vlsir::tetris::TrackRef::MergeFrom(
        from._internal_into());
  }
  if (from._internal_track() != 0) {
    _this->_internal_set_track(from._internal_track());
  }
  if (from._internal_side() != 0) {
    _this->_internal_set_side(from._internal_side());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AbstractPort_ZTopEdgePort::CopyFrom(const AbstractPort_ZTopEdgePort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.AbstractPort.ZTopEdgePort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbstractPort_ZTopEdgePort::IsInitialized() const {
  return true;
}

void AbstractPort_ZTopEdgePort::InternalSwap(AbstractPort_ZTopEdgePort* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AbstractPort_ZTopEdgePort, _impl_.side_)
      + sizeof(AbstractPort_ZTopEdgePort::_impl_.side_)
      - PROTOBUF_FIELD_OFFSET(AbstractPort_ZTopEdgePort, _impl_.into_)>(
          reinterpret_cast<char*>(&_impl_.into_),
          reinterpret_cast<char*>(&other->_impl_.into_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AbstractPort_ZTopEdgePort::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[9]);
}

// ===================================================================

class AbstractPort_ZTopInner::_Internal {
 public:
};

AbstractPort_ZTopInner::AbstractPort_ZTopInner(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.AbstractPort.ZTopInner)
}
AbstractPort_ZTopInner::AbstractPort_ZTopInner(const AbstractPort_ZTopInner& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AbstractPort_ZTopInner* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.locs_){from._impl_.locs_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.AbstractPort.ZTopInner)
}

inline void AbstractPort_ZTopInner::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.locs_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AbstractPort_ZTopInner::~AbstractPort_ZTopInner() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.AbstractPort.ZTopInner)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AbstractPort_ZTopInner::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.locs_.~RepeatedPtrField();
}

void AbstractPort_ZTopInner::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AbstractPort_ZTopInner::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.AbstractPort.ZTopInner)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.locs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AbstractPort_ZTopInner::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vlsir.tetris.TrackCross locs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_locs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AbstractPort_ZTopInner::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.AbstractPort.ZTopInner)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackCross locs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_locs_size()); i < n; i++) {
    const auto& repfield = this->_internal_locs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.AbstractPort.ZTopInner)
  return target;
}

size_t AbstractPort_ZTopInner::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.AbstractPort.ZTopInner)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackCross locs = 1;
  total_size += 1UL * this->_internal_locs_size();
  for (const auto& msg : this->_impl_.locs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AbstractPort_ZTopInner::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AbstractPort_ZTopInner::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AbstractPort_ZTopInner::GetClassData() const { return &_class_data_; }


void AbstractPort_ZTopInner::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AbstractPort_ZTopInner*>(&to_msg);
  auto& from = static_cast<const AbstractPort_ZTopInner&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.AbstractPort.ZTopInner)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.locs_.MergeFrom(from._impl_.locs_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AbstractPort_ZTopInner::CopyFrom(const AbstractPort_ZTopInner& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.AbstractPort.ZTopInner)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbstractPort_ZTopInner::IsInitialized() const {
  return true;
}

void AbstractPort_ZTopInner::InternalSwap(AbstractPort_ZTopInner* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.locs_.InternalSwap(&other->_impl_.locs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AbstractPort_ZTopInner::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[10]);
}

// ===================================================================

class AbstractPort::_Internal {
 public:
  static const ::vlsir::tetris::AbstractPort_EdgePort& edge(const AbstractPort* msg);
  static const ::vlsir::tetris::AbstractPort_ZTopEdgePort& ztop_edge(const AbstractPort* msg);
  static const ::vlsir::tetris::AbstractPort_ZTopInner& ztop_inner(const AbstractPort* msg);
};

const ::vlsir::tetris::AbstractPort_EdgePort&
AbstractPort::_Internal::edge(const AbstractPort* msg) {
  return *msg->_impl_.kind_.edge_;
}
const ::vlsir::tetris::AbstractPort_ZTopEdgePort&
AbstractPort::_Internal::ztop_edge(const AbstractPort* msg) {
  return *msg->_impl_.kind_.ztop_edge_;
}
const ::vlsir::tetris::AbstractPort_ZTopInner&
AbstractPort::_Internal::ztop_inner(const AbstractPort* msg) {
  return *msg->_impl_.kind_.ztop_inner_;
}
void AbstractPort::set_allocated_edge(::vlsir::tetris::AbstractPort_EdgePort* edge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (edge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(edge);
    if (message_arena != submessage_arena) {
      edge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge, submessage_arena);
    }
    set_has_edge();
    _impl_.kind_.edge_ = edge;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.AbstractPort.edge)
}
void AbstractPort::set_allocated_ztop_edge(::vlsir::tetris::AbstractPort_ZTopEdgePort* ztop_edge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (ztop_edge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ztop_edge);
    if (message_arena != submessage_arena) {
      ztop_edge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ztop_edge, submessage_arena);
    }
    set_has_ztop_edge();
    _impl_.kind_.ztop_edge_ = ztop_edge;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.AbstractPort.ztop_edge)
}
void AbstractPort::set_allocated_ztop_inner(::vlsir::tetris::AbstractPort_ZTopInner* ztop_inner) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (ztop_inner) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ztop_inner);
    if (message_arena != submessage_arena) {
      ztop_inner = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ztop_inner, submessage_arena);
    }
    set_has_ztop_inner();
    _impl_.kind_.ztop_inner_ = ztop_inner;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.AbstractPort.ztop_inner)
}
AbstractPort::AbstractPort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.AbstractPort)
}
AbstractPort::AbstractPort(const AbstractPort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AbstractPort* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.net_){}
    , decltype(_impl_.kind_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.net_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_net().empty()) {
    _this->_impl_.net_.Set(from._internal_net(), 
      _this->GetArenaForAllocation());
  }
  clear_has_kind();
  switch (from.kind_case()) {
    case kEdge: {
      _this->_internal_mutable_edge()->::vlsir::tetris::AbstractPort_EdgePort::MergeFrom(
          from._internal_edge());
      break;
    }
    case kZtopEdge: {
      _this->_internal_mutable_ztop_edge()->::vlsir::tetris::AbstractPort_ZTopEdgePort::MergeFrom(
          from._internal_ztop_edge());
      break;
    }
    case kZtopInner: {
      _this->_internal_mutable_ztop_inner()->::vlsir::tetris::AbstractPort_ZTopInner::MergeFrom(
          from._internal_ztop_inner());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.AbstractPort)
}

inline void AbstractPort::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.net_){}
    , decltype(_impl_.kind_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.net_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_kind();
}

AbstractPort::~AbstractPort() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.AbstractPort)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AbstractPort::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.net_.Destroy();
  if (has_kind()) {
    clear_kind();
  }
}

void AbstractPort::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AbstractPort::clear_kind() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.tetris.AbstractPort)
  switch (kind_case()) {
    case kEdge: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.edge_;
      }
      break;
    }
    case kZtopEdge: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.ztop_edge_;
      }
      break;
    }
    case kZtopInner: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.ztop_inner_;
      }
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}


void AbstractPort::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.AbstractPort)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.net_.ClearToEmpty();
  clear_kind();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AbstractPort::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string net = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_net();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.tetris.AbstractPort.net"));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.EdgePort edge = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_edge(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.ZTopEdgePort ztop_edge = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_ztop_edge(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.AbstractPort.ZTopInner ztop_inner = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_ztop_inner(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AbstractPort::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.AbstractPort)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string net = 1;
  if (!this->_internal_net().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_net().data(), static_cast<int>(this->_internal_net().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.AbstractPort.net");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_net(), target);
  }

  // .vlsir.tetris.AbstractPort.EdgePort edge = 10;
  if (_internal_has_edge()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::edge(this),
        _Internal::edge(this).GetCachedSize(), target, stream);
  }

  // .vlsir.tetris.AbstractPort.ZTopEdgePort ztop_edge = 11;
  if (_internal_has_ztop_edge()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::ztop_edge(this),
        _Internal::ztop_edge(this).GetCachedSize(), target, stream);
  }

  // .vlsir.tetris.AbstractPort.ZTopInner ztop_inner = 12;
  if (_internal_has_ztop_inner()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::ztop_inner(this),
        _Internal::ztop_inner(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.AbstractPort)
  return target;
}

size_t AbstractPort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.AbstractPort)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string net = 1;
  if (!this->_internal_net().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_net());
  }

  switch (kind_case()) {
    // .vlsir.tetris.AbstractPort.EdgePort edge = 10;
    case kEdge: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.edge_);
      break;
    }
    // .vlsir.tetris.AbstractPort.ZTopEdgePort ztop_edge = 11;
    case kZtopEdge: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.ztop_edge_);
      break;
    }
    // .vlsir.tetris.AbstractPort.ZTopInner ztop_inner = 12;
    case kZtopInner: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.ztop_inner_);
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AbstractPort::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AbstractPort::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AbstractPort::GetClassData() const { return &_class_data_; }


void AbstractPort::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AbstractPort*>(&to_msg);
  auto& from = static_cast<const AbstractPort&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.AbstractPort)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_net().empty()) {
    _this->_internal_set_net(from._internal_net());
  }
  switch (from.kind_case()) {
    case kEdge: {
      _this->_internal_mutable_edge()->::vlsir::tetris::AbstractPort_EdgePort::MergeFrom(
          from._internal_edge());
      break;
    }
    case kZtopEdge: {
      _this->_internal_mutable_ztop_edge()->::vlsir::tetris::AbstractPort_ZTopEdgePort::MergeFrom(
          from._internal_ztop_edge());
      break;
    }
    case kZtopInner: {
      _this->_internal_mutable_ztop_inner()->::vlsir::tetris::AbstractPort_ZTopInner::MergeFrom(
          from._internal_ztop_inner());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AbstractPort::CopyFrom(const AbstractPort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.AbstractPort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AbstractPort::IsInitialized() const {
  return true;
}

void AbstractPort::InternalSwap(AbstractPort* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.net_, lhs_arena,
      &other->_impl_.net_, rhs_arena
  );
  swap(_impl_.kind_, other->_impl_.kind_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata AbstractPort::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[11]);
}

// ===================================================================

class Instance::_Internal {
 public:
  static const ::vlsir::utils::Reference& cell(const Instance* msg);
  static const ::vlsir::tetris::Place& loc(const Instance* msg);
};

const ::vlsir::utils::Reference&
Instance::_Internal::cell(const Instance* msg) {
  return *msg->_impl_.cell_;
}
const ::vlsir::tetris::Place&
Instance::_Internal::loc(const Instance* msg) {
  return *msg->_impl_.loc_;
}
void Instance::clear_cell() {
  if (GetArenaForAllocation() == nullptr && _impl_.cell_ != nullptr) {
    delete _impl_.cell_;
  }
  _impl_.cell_ = nullptr;
}
Instance::Instance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Instance)
}
Instance::Instance(const Instance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Instance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.cell_){nullptr}
    , decltype(_impl_.loc_){nullptr}
    , decltype(_impl_.reflect_horiz_){}
    , decltype(_impl_.reflect_vert_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_cell()) {
    _this->_impl_.cell_ = new ::vlsir::utils::Reference(*from._impl_.cell_);
  }
  if (from._internal_has_loc()) {
    _this->_impl_.loc_ = new ::vlsir::tetris::Place(*from._impl_.loc_);
  }
  ::memcpy(&_impl_.reflect_horiz_, &from._impl_.reflect_horiz_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.reflect_vert_) -
    reinterpret_cast<char*>(&_impl_.reflect_horiz_)) + sizeof(_impl_.reflect_vert_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Instance)
}

inline void Instance::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.cell_){nullptr}
    , decltype(_impl_.loc_){nullptr}
    , decltype(_impl_.reflect_horiz_){false}
    , decltype(_impl_.reflect_vert_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Instance::~Instance() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Instance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Instance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.cell_;
  if (this != internal_default_instance()) delete _impl_.loc_;
}

void Instance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Instance::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Instance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.cell_ != nullptr) {
    delete _impl_.cell_;
  }
  _impl_.cell_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.loc_ != nullptr) {
    delete _impl_.loc_;
  }
  _impl_.loc_ = nullptr;
  ::memset(&_impl_.reflect_horiz_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.reflect_vert_) -
      reinterpret_cast<char*>(&_impl_.reflect_horiz_)) + sizeof(_impl_.reflect_vert_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Instance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.tetris.Instance.name"));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.utils.Reference cell = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cell(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.Place loc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_loc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reflect_horiz = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.reflect_horiz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reflect_vert = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.reflect_vert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Instance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Instance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.Instance.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.utils.Reference cell = 3;
  if (this->_internal_has_cell()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::cell(this),
        _Internal::cell(this).GetCachedSize(), target, stream);
  }

  // .vlsir.tetris.Place loc = 4;
  if (this->_internal_has_loc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::loc(this),
        _Internal::loc(this).GetCachedSize(), target, stream);
  }

  // bool reflect_horiz = 6;
  if (this->_internal_reflect_horiz() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_reflect_horiz(), target);
  }

  // bool reflect_vert = 7;
  if (this->_internal_reflect_vert() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_reflect_vert(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Instance)
  return target;
}

size_t Instance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Instance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.utils.Reference cell = 3;
  if (this->_internal_has_cell()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cell_);
  }

  // .vlsir.tetris.Place loc = 4;
  if (this->_internal_has_loc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.loc_);
  }

  // bool reflect_horiz = 6;
  if (this->_internal_reflect_horiz() != 0) {
    total_size += 1 + 1;
  }

  // bool reflect_vert = 7;
  if (this->_internal_reflect_vert() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Instance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Instance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Instance::GetClassData() const { return &_class_data_; }


void Instance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Instance*>(&to_msg);
  auto& from = static_cast<const Instance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Instance)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_cell()) {
    _this->_internal_mutable_cell()->::vlsir::utils::Reference::MergeFrom(
        from._internal_cell());
  }
  if (from._internal_has_loc()) {
    _this->_internal_mutable_loc()->::vlsir::tetris::Place::MergeFrom(
        from._internal_loc());
  }
  if (from._internal_reflect_horiz() != 0) {
    _this->_internal_set_reflect_horiz(from._internal_reflect_horiz());
  }
  if (from._internal_reflect_vert() != 0) {
    _this->_internal_set_reflect_vert(from._internal_reflect_vert());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Instance::CopyFrom(const Instance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Instance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Instance::IsInitialized() const {
  return true;
}

void Instance::InternalSwap(Instance* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Instance, _impl_.reflect_vert_)
      + sizeof(Instance::_impl_.reflect_vert_)
      - PROTOBUF_FIELD_OFFSET(Instance, _impl_.cell_)>(
          reinterpret_cast<char*>(&_impl_.cell_),
          reinterpret_cast<char*>(&other->_impl_.cell_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Instance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[12]);
}

// ===================================================================

class Place::_Internal {
 public:
  static const ::vlsir::raw::Point& abs(const Place* msg);
  static const ::vlsir::tetris::RelPlace& rel(const Place* msg);
};

const ::vlsir::raw::Point&
Place::_Internal::abs(const Place* msg) {
  return *msg->_impl_.place_.abs_;
}
const ::vlsir::tetris::RelPlace&
Place::_Internal::rel(const Place* msg) {
  return *msg->_impl_.place_.rel_;
}
void Place::set_allocated_abs(::vlsir::raw::Point* abs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_place();
  if (abs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(abs));
    if (message_arena != submessage_arena) {
      abs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, abs, submessage_arena);
    }
    set_has_abs();
    _impl_.place_.abs_ = abs;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Place.abs)
}
void Place::clear_abs() {
  if (_internal_has_abs()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.place_.abs_;
    }
    clear_has_place();
  }
}
void Place::set_allocated_rel(::vlsir::tetris::RelPlace* rel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_place();
  if (rel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rel);
    if (message_arena != submessage_arena) {
      rel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rel, submessage_arena);
    }
    set_has_rel();
    _impl_.place_.rel_ = rel;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.Place.rel)
}
Place::Place(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Place)
}
Place::Place(const Place& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Place* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.place_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_place();
  switch (from.place_case()) {
    case kAbs: {
      _this->_internal_mutable_abs()->::vlsir::raw::Point::MergeFrom(
          from._internal_abs());
      break;
    }
    case kRel: {
      _this->_internal_mutable_rel()->::vlsir::tetris::RelPlace::MergeFrom(
          from._internal_rel());
      break;
    }
    case PLACE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Place)
}

inline void Place::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.place_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_place();
}

Place::~Place() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Place)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Place::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_place()) {
    clear_place();
  }
}

void Place::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Place::clear_place() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.tetris.Place)
  switch (place_case()) {
    case kAbs: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.place_.abs_;
      }
      break;
    }
    case kRel: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.place_.rel_;
      }
      break;
    }
    case PLACE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PLACE_NOT_SET;
}


void Place::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Place)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_place();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Place::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.raw.Point abs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_abs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.RelPlace rel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Place::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Place)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.raw.Point abs = 1;
  if (_internal_has_abs()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::abs(this),
        _Internal::abs(this).GetCachedSize(), target, stream);
  }

  // .vlsir.tetris.RelPlace rel = 2;
  if (_internal_has_rel()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rel(this),
        _Internal::rel(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Place)
  return target;
}

size_t Place::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Place)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (place_case()) {
    // .vlsir.raw.Point abs = 1;
    case kAbs: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.place_.abs_);
      break;
    }
    // .vlsir.tetris.RelPlace rel = 2;
    case kRel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.place_.rel_);
      break;
    }
    case PLACE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Place::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Place::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Place::GetClassData() const { return &_class_data_; }


void Place::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Place*>(&to_msg);
  auto& from = static_cast<const Place&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Place)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.place_case()) {
    case kAbs: {
      _this->_internal_mutable_abs()->::vlsir::raw::Point::MergeFrom(
          from._internal_abs());
      break;
    }
    case kRel: {
      _this->_internal_mutable_rel()->::vlsir::tetris::RelPlace::MergeFrom(
          from._internal_rel());
      break;
    }
    case PLACE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Place::CopyFrom(const Place& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Place)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Place::IsInitialized() const {
  return true;
}

void Place::InternalSwap(Place* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.place_, other->_impl_.place_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Place::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[13]);
}

// ===================================================================

class RelPlace::_Internal {
 public:
};

RelPlace::RelPlace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.RelPlace)
}
RelPlace::RelPlace(const RelPlace& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  RelPlace* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.RelPlace)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RelPlace::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RelPlace::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata RelPlace::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[14]);
}

// ===================================================================

class Stack::_Internal {
 public:
  static const ::vlsir::tetris::PrimitiveLayer& prim(const Stack* msg);
  static const ::vlsir::raw::Layer& boundary_layer(const Stack* msg);
};

const ::vlsir::tetris::PrimitiveLayer&
Stack::_Internal::prim(const Stack* msg) {
  return *msg->_impl_.prim_;
}
const ::vlsir::raw::Layer&
Stack::_Internal::boundary_layer(const Stack* msg) {
  return *msg->_impl_.boundary_layer_;
}
void Stack::clear_boundary_layer() {
  if (GetArenaForAllocation() == nullptr && _impl_.boundary_layer_ != nullptr) {
    delete _impl_.boundary_layer_;
  }
  _impl_.boundary_layer_ = nullptr;
}
Stack::Stack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Stack)
}
Stack::Stack(const Stack& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Stack* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.metals_){from._impl_.metals_}
    , decltype(_impl_.vias_){from._impl_.vias_}
    , decltype(_impl_.prim_){nullptr}
    , decltype(_impl_.boundary_layer_){nullptr}
    , decltype(_impl_.units_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_prim()) {
    _this->_impl_.prim_ = new ::vlsir::tetris::PrimitiveLayer(*from._impl_.prim_);
  }
  if (from._internal_has_boundary_layer()) {
    _this->_impl_.boundary_layer_ = new ::vlsir::raw::Layer(*from._impl_.boundary_layer_);
  }
  _this->_impl_.units_ = from._impl_.units_;
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Stack)
}

inline void Stack::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.metals_){arena}
    , decltype(_impl_.vias_){arena}
    , decltype(_impl_.prim_){nullptr}
    , decltype(_impl_.boundary_layer_){nullptr}
    , decltype(_impl_.units_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Stack::~Stack() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Stack)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Stack::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.metals_.~RepeatedPtrField();
  _impl_.vias_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.prim_;
  if (this != internal_default_instance()) delete _impl_.boundary_layer_;
}

void Stack::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Stack::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Stack)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.metals_.Clear();
  _impl_.vias_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.prim_ != nullptr) {
    delete _impl_.prim_;
  }
  _impl_.prim_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.boundary_layer_ != nullptr) {
    delete _impl_.boundary_layer_;
  }
  _impl_.boundary_layer_ = nullptr;
  _impl_.units_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Stack::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.raw.Units units = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_units(static_cast<::vlsir::raw::Units>(val));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.PrimitiveLayer prim = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_prim(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.MetalLayer metals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_metals(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.ViaLayer vias = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vias(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.raw.Layer boundary_layer = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_boundary_layer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Stack::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Stack)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.raw.Units units = 1;
  if (this->_internal_units() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_units(), target);
  }

  // .vlsir.tetris.PrimitiveLayer prim = 2;
  if (this->_internal_has_prim()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::prim(this),
        _Internal::prim(this).GetCachedSize(), target, stream);
  }

  // repeated .vlsir.tetris.MetalLayer metals = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_metals_size()); i < n; i++) {
    const auto& repfield = this->_internal_metals(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .vlsir.tetris.ViaLayer vias = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_vias_size()); i < n; i++) {
    const auto& repfield = this->_internal_vias(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .vlsir.raw.Layer boundary_layer = 11;
  if (this->_internal_has_boundary_layer()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::boundary_layer(this),
        _Internal::boundary_layer(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Stack)
  return target;
}

size_t Stack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Stack)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.MetalLayer metals = 3;
  total_size += 1UL * this->_internal_metals_size();
  for (const auto& msg : this->_impl_.metals_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vlsir.tetris.ViaLayer vias = 4;
  total_size += 1UL * this->_internal_vias_size();
  for (const auto& msg : this->_impl_.vias_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .vlsir.tetris.PrimitiveLayer prim = 2;
  if (this->_internal_has_prim()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.prim_);
  }

  // .vlsir.raw.Layer boundary_layer = 11;
  if (this->_internal_has_boundary_layer()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.boundary_layer_);
  }

  // .vlsir.raw.Units units = 1;
  if (this->_internal_units() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_units());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Stack::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Stack::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Stack::GetClassData() const { return &_class_data_; }


void Stack::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Stack*>(&to_msg);
  auto& from = static_cast<const Stack&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Stack)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.metals_.MergeFrom(from._impl_.metals_);
  _this->_impl_.vias_.MergeFrom(from._impl_.vias_);
  if (from._internal_has_prim()) {
    _this->_internal_mutable_prim()->::vlsir::tetris::PrimitiveLayer::MergeFrom(
        from._internal_prim());
  }
  if (from._internal_has_boundary_layer()) {
    _this->_internal_mutable_boundary_layer()->::vlsir::raw::Layer::MergeFrom(
        from._internal_boundary_layer());
  }
  if (from._internal_units() != 0) {
    _this->_internal_set_units(from._internal_units());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Stack::CopyFrom(const Stack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Stack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stack::IsInitialized() const {
  return true;
}

void Stack::InternalSwap(Stack* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.metals_.InternalSwap(&other->_impl_.metals_);
  _impl_.vias_.InternalSwap(&other->_impl_.vias_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Stack, _impl_.units_)
      + sizeof(Stack::_impl_.units_)
      - PROTOBUF_FIELD_OFFSET(Stack, _impl_.prim_)>(
          reinterpret_cast<char*>(&_impl_.prim_),
          reinterpret_cast<char*>(&other->_impl_.prim_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Stack::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[15]);
}

// ===================================================================

class LayerEnum::_Internal {
 public:
};

LayerEnum::LayerEnum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.LayerEnum)
}
LayerEnum::LayerEnum(const LayerEnum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LayerEnum* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.index_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.index_, &from._impl_.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.LayerEnum)
}

inline void LayerEnum::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.index_){int64_t{0}}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

LayerEnum::~LayerEnum() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.LayerEnum)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LayerEnum::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LayerEnum::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LayerEnum::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.LayerEnum)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LayerEnum::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.tetris.LayerEnum.LayerType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::vlsir::tetris::LayerEnum_LayerType>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LayerEnum::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.LayerEnum)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.LayerEnum.LayerType type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // int64 index = 2;
  if (this->_internal_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.LayerEnum)
  return target;
}

size_t LayerEnum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.LayerEnum)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 index = 2;
  if (this->_internal_index() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_index());
  }

  // .vlsir.tetris.LayerEnum.LayerType type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LayerEnum::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LayerEnum::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LayerEnum::GetClassData() const { return &_class_data_; }


void LayerEnum::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LayerEnum*>(&to_msg);
  auto& from = static_cast<const LayerEnum&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.LayerEnum)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_index() != 0) {
    _this->_internal_set_index(from._internal_index());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LayerEnum::CopyFrom(const LayerEnum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.LayerEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LayerEnum::IsInitialized() const {
  return true;
}

void LayerEnum::InternalSwap(LayerEnum* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LayerEnum, _impl_.type_)
      + sizeof(LayerEnum::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(LayerEnum, _impl_.index_)>(
          reinterpret_cast<char*>(&_impl_.index_),
          reinterpret_cast<char*>(&other->_impl_.index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LayerEnum::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[16]);
}

// ===================================================================

class MetalLayer::_Internal {
 public:
  static const ::vlsir::raw::Layer& raw(const MetalLayer* msg);
};

const ::vlsir::raw::Layer&
MetalLayer::_Internal::raw(const MetalLayer* msg) {
  return *msg->_impl_.raw_;
}
void MetalLayer::clear_raw() {
  if (GetArenaForAllocation() == nullptr && _impl_.raw_ != nullptr) {
    delete _impl_.raw_;
  }
  _impl_.raw_ = nullptr;
}
MetalLayer::MetalLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.MetalLayer)
}
MetalLayer::MetalLayer(const MetalLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MetalLayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){from._impl_.entries_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.raw_){nullptr}
    , decltype(_impl_.cutsize_){}
    , decltype(_impl_.dir_){}
    , decltype(_impl_.flip_){}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.overlap_){}
    , decltype(_impl_.prim_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_raw()) {
    _this->_impl_.raw_ = new ::vlsir::raw::Layer(*from._impl_.raw_);
  }
  ::memcpy(&_impl_.cutsize_, &from._impl_.cutsize_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prim_) -
    reinterpret_cast<char*>(&_impl_.cutsize_)) + sizeof(_impl_.prim_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.MetalLayer)
}

inline void MetalLayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.raw_){nullptr}
    , decltype(_impl_.cutsize_){int64_t{0}}
    , decltype(_impl_.dir_){0}
    , decltype(_impl_.flip_){false}
    , decltype(_impl_.offset_){int64_t{0}}
    , decltype(_impl_.overlap_){int64_t{0}}
    , decltype(_impl_.prim_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MetalLayer::~MetalLayer() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.MetalLayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MetalLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entries_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.raw_;
}

void MetalLayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MetalLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.MetalLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.raw_ != nullptr) {
    delete _impl_.raw_;
  }
  _impl_.raw_ = nullptr;
  ::memset(&_impl_.cutsize_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.prim_) -
      reinterpret_cast<char*>(&_impl_.cutsize_)) + sizeof(_impl_.prim_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MetalLayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.tetris.MetalLayer.name"));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.MetalLayer.Dir dir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_dir(static_cast<::vlsir::tetris::MetalLayer_Dir>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 cutsize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.cutsize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vlsir.tetris.TrackSpec entries = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int64 offset = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 overlap = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.overlap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool flip = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.flip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.MetalLayer.PrimitiveMode prim = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_prim(static_cast<::vlsir::tetris::MetalLayer_PrimitiveMode>(val));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.raw.Layer raw = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MetalLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.MetalLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.MetalLayer.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.tetris.MetalLayer.Dir dir = 2;
  if (this->_internal_dir() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_dir(), target);
  }

  // int64 cutsize = 3;
  if (this->_internal_cutsize() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_cutsize(), target);
  }

  // repeated .vlsir.tetris.TrackSpec entries = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int64 offset = 5;
  if (this->_internal_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_offset(), target);
  }

  // int64 overlap = 6;
  if (this->_internal_overlap() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_overlap(), target);
  }

  // bool flip = 7;
  if (this->_internal_flip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_flip(), target);
  }

  // .vlsir.tetris.MetalLayer.PrimitiveMode prim = 8;
  if (this->_internal_prim() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_prim(), target);
  }

  // .vlsir.raw.Layer raw = 11;
  if (this->_internal_has_raw()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::raw(this),
        _Internal::raw(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.MetalLayer)
  return target;
}

size_t MetalLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.MetalLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackSpec entries = 4;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_impl_.entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.raw.Layer raw = 11;
  if (this->_internal_has_raw()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.raw_);
  }

  // int64 cutsize = 3;
  if (this->_internal_cutsize() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_cutsize());
  }

  // .vlsir.tetris.MetalLayer.Dir dir = 2;
  if (this->_internal_dir() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dir());
  }

  // bool flip = 7;
  if (this->_internal_flip() != 0) {
    total_size += 1 + 1;
  }

  // int64 offset = 5;
  if (this->_internal_offset() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
  }

  // int64 overlap = 6;
  if (this->_internal_overlap() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_overlap());
  }

  // .vlsir.tetris.MetalLayer.PrimitiveMode prim = 8;
  if (this->_internal_prim() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_prim());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MetalLayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MetalLayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MetalLayer::GetClassData() const { return &_class_data_; }


void MetalLayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MetalLayer*>(&to_msg);
  auto& from = static_cast<const MetalLayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.MetalLayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_raw()) {
    _this->_internal_mutable_raw()->::vlsir::raw::Layer::MergeFrom(
        from._internal_raw());
  }
  if (from._internal_cutsize() != 0) {
    _this->_internal_set_cutsize(from._internal_cutsize());
  }
  if (from._internal_dir() != 0) {
    _this->_internal_set_dir(from._internal_dir());
  }
  if (from._internal_flip() != 0) {
    _this->_internal_set_flip(from._internal_flip());
  }
  if (from._internal_offset() != 0) {
    _this->_internal_set_offset(from._internal_offset());
  }
  if (from._internal_overlap() != 0) {
    _this->_internal_set_overlap(from._internal_overlap());
  }
  if (from._internal_prim() != 0) {
    _this->_internal_set_prim(from._internal_prim());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MetalLayer::CopyFrom(const MetalLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.MetalLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MetalLayer::IsInitialized() const {
  return true;
}

void MetalLayer::InternalSwap(MetalLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MetalLayer, _impl_.prim_)
      + sizeof(MetalLayer::_impl_.prim_)
      - PROTOBUF_FIELD_OFFSET(MetalLayer, _impl_.raw_)>(
          reinterpret_cast<char*>(&_impl_.raw_),
          reinterpret_cast<char*>(&other->_impl_.raw_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MetalLayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[17]);
}

// ===================================================================

class ViaLayer::_Internal {
 public:
  static const ::vlsir::tetris::LayerEnum& top(const ViaLayer* msg);
  static const ::vlsir::tetris::LayerEnum& bot(const ViaLayer* msg);
  static const ::vlsir::tetris::Xy& size(const ViaLayer* msg);
  static const ::vlsir::raw::Layer& raw(const ViaLayer* msg);
};

const ::vlsir::tetris::LayerEnum&
ViaLayer::_Internal::top(const ViaLayer* msg) {
  return *msg->_impl_.top_;
}
const ::vlsir::tetris::LayerEnum&
ViaLayer::_Internal::bot(const ViaLayer* msg) {
  return *msg->_impl_.bot_;
}
const ::vlsir::tetris::Xy&
ViaLayer::_Internal::size(const ViaLayer* msg) {
  return *msg->_impl_.size_;
}
const ::vlsir::raw::Layer&
ViaLayer::_Internal::raw(const ViaLayer* msg) {
  return *msg->_impl_.raw_;
}
void ViaLayer::clear_raw() {
  if (GetArenaForAllocation() == nullptr && _impl_.raw_ != nullptr) {
    delete _impl_.raw_;
  }
  _impl_.raw_ = nullptr;
}
ViaLayer::ViaLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.ViaLayer)
}
ViaLayer::ViaLayer(const ViaLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ViaLayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.top_){nullptr}
    , decltype(_impl_.bot_){nullptr}
    , decltype(_impl_.size_){nullptr}
    , decltype(_impl_.raw_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_top()) {
    _this->_impl_.top_ = new ::vlsir::tetris::LayerEnum(*from._impl_.top_);
  }
  if (from._internal_has_bot()) {
    _this->_impl_.bot_ = new ::vlsir::tetris::LayerEnum(*from._impl_.bot_);
  }
  if (from._internal_has_size()) {
    _this->_impl_.size_ = new ::vlsir::tetris::Xy(*from._impl_.size_);
  }
  if (from._internal_has_raw()) {
    _this->_impl_.raw_ = new ::vlsir::raw::Layer(*from._impl_.raw_);
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.ViaLayer)
}

inline void ViaLayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.top_){nullptr}
    , decltype(_impl_.bot_){nullptr}
    , decltype(_impl_.size_){nullptr}
    , decltype(_impl_.raw_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ViaLayer::~ViaLayer() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.ViaLayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ViaLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.top_;
  if (this != internal_default_instance()) delete _impl_.bot_;
  if (this != internal_default_instance()) delete _impl_.size_;
  if (this != internal_default_instance()) delete _impl_.raw_;
}

void ViaLayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ViaLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.ViaLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.top_ != nullptr) {
    delete _impl_.top_;
  }
  _impl_.top_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.bot_ != nullptr) {
    delete _impl_.bot_;
  }
  _impl_.bot_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.size_ != nullptr) {
    delete _impl_.size_;
  }
  _impl_.size_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.raw_ != nullptr) {
    delete _impl_.raw_;
  }
  _impl_.raw_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ViaLayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vlsir.tetris.ViaLayer.name"));
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.LayerEnum top = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_top(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.LayerEnum bot = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_bot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.Xy size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.raw.Layer raw = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ViaLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.ViaLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vlsir.tetris.ViaLayer.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .vlsir.tetris.LayerEnum top = 2;
  if (this->_internal_has_top()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::top(this),
        _Internal::top(this).GetCachedSize(), target, stream);
  }

  // .vlsir.tetris.LayerEnum bot = 3;
  if (this->_internal_has_bot()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::bot(this),
        _Internal::bot(this).GetCachedSize(), target, stream);
  }

  // .vlsir.tetris.Xy size = 4;
  if (this->_internal_has_size()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::size(this),
        _Internal::size(this).GetCachedSize(), target, stream);
  }

  // .vlsir.raw.Layer raw = 11;
  if (this->_internal_has_raw()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::raw(this),
        _Internal::raw(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.ViaLayer)
  return target;
}

size_t ViaLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.ViaLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vlsir.tetris.LayerEnum top = 2;
  if (this->_internal_has_top()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.top_);
  }

  // .vlsir.tetris.LayerEnum bot = 3;
  if (this->_internal_has_bot()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.bot_);
  }

  // .vlsir.tetris.Xy size = 4;
  if (this->_internal_has_size()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.size_);
  }

  // .vlsir.raw.Layer raw = 11;
  if (this->_internal_has_raw()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.raw_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ViaLayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ViaLayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ViaLayer::GetClassData() const { return &_class_data_; }


void ViaLayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ViaLayer*>(&to_msg);
  auto& from = static_cast<const ViaLayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.ViaLayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_top()) {
    _this->_internal_mutable_top()->::vlsir::tetris::LayerEnum::MergeFrom(
        from._internal_top());
  }
  if (from._internal_has_bot()) {
    _this->_internal_mutable_bot()->::vlsir::tetris::LayerEnum::MergeFrom(
        from._internal_bot());
  }
  if (from._internal_has_size()) {
    _this->_internal_mutable_size()->::vlsir::tetris::Xy::MergeFrom(
        from._internal_size());
  }
  if (from._internal_has_raw()) {
    _this->_internal_mutable_raw()->::vlsir::raw::Layer::MergeFrom(
        from._internal_raw());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ViaLayer::CopyFrom(const ViaLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.ViaLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ViaLayer::IsInitialized() const {
  return true;
}

void ViaLayer::InternalSwap(ViaLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ViaLayer, _impl_.raw_)
      + sizeof(ViaLayer::_impl_.raw_)
      - PROTOBUF_FIELD_OFFSET(ViaLayer, _impl_.top_)>(
          reinterpret_cast<char*>(&_impl_.top_),
          reinterpret_cast<char*>(&other->_impl_.top_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ViaLayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[18]);
}

// ===================================================================

class PrimitiveLayer::_Internal {
 public:
  static const ::vlsir::tetris::Xy& pitches(const PrimitiveLayer* msg);
};

const ::vlsir::tetris::Xy&
PrimitiveLayer::_Internal::pitches(const PrimitiveLayer* msg) {
  return *msg->_impl_.pitches_;
}
PrimitiveLayer::PrimitiveLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.PrimitiveLayer)
}
PrimitiveLayer::PrimitiveLayer(const PrimitiveLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PrimitiveLayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pitches_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pitches()) {
    _this->_impl_.pitches_ = new ::vlsir::tetris::Xy(*from._impl_.pitches_);
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.PrimitiveLayer)
}

inline void PrimitiveLayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pitches_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PrimitiveLayer::~PrimitiveLayer() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.PrimitiveLayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PrimitiveLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pitches_;
}

void PrimitiveLayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PrimitiveLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.PrimitiveLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pitches_ != nullptr) {
    delete _impl_.pitches_;
  }
  _impl_.pitches_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PrimitiveLayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.tetris.Xy pitches = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pitches(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PrimitiveLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.PrimitiveLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.Xy pitches = 1;
  if (this->_internal_has_pitches()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pitches(this),
        _Internal::pitches(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.PrimitiveLayer)
  return target;
}

size_t PrimitiveLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.PrimitiveLayer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vlsir.tetris.Xy pitches = 1;
  if (this->_internal_has_pitches()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pitches_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PrimitiveLayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PrimitiveLayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PrimitiveLayer::GetClassData() const { return &_class_data_; }


void PrimitiveLayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PrimitiveLayer*>(&to_msg);
  auto& from = static_cast<const PrimitiveLayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.PrimitiveLayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pitches()) {
    _this->_internal_mutable_pitches()->::vlsir::tetris::Xy::MergeFrom(
        from._internal_pitches());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PrimitiveLayer::CopyFrom(const PrimitiveLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.PrimitiveLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrimitiveLayer::IsInitialized() const {
  return true;
}

void PrimitiveLayer::InternalSwap(PrimitiveLayer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.pitches_, other->_impl_.pitches_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PrimitiveLayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[19]);
}

// ===================================================================

class TrackSpec_TrackEntry::_Internal {
 public:
};

TrackSpec_TrackEntry::TrackSpec_TrackEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackSpec.TrackEntry)
}
TrackSpec_TrackEntry::TrackSpec_TrackEntry(const TrackSpec_TrackEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TrackSpec_TrackEntry* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.width_){}
    , decltype(_impl_.ttype_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ttype_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.ttype_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackSpec.TrackEntry)
}

inline void TrackSpec_TrackEntry::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.width_){int64_t{0}}
    , decltype(_impl_.ttype_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TrackSpec_TrackEntry::~TrackSpec_TrackEntry() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackSpec.TrackEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrackSpec_TrackEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TrackSpec_TrackEntry::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrackSpec_TrackEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackSpec.TrackEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.ttype_) -
      reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.ttype_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackSpec_TrackEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.tetris.TrackSpec.TrackEntry.TrackType ttype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_ttype(static_cast<::vlsir::tetris::TrackSpec_TrackEntry_TrackType>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackSpec_TrackEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackSpec.TrackEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.TrackSpec.TrackEntry.TrackType ttype = 1;
  if (this->_internal_ttype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_ttype(), target);
  }

  // int64 width = 2;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackSpec.TrackEntry)
  return target;
}

size_t TrackSpec_TrackEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackSpec.TrackEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 width = 2;
  if (this->_internal_width() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_width());
  }

  // .vlsir.tetris.TrackSpec.TrackEntry.TrackType ttype = 1;
  if (this->_internal_ttype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_ttype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackSpec_TrackEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TrackSpec_TrackEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackSpec_TrackEntry::GetClassData() const { return &_class_data_; }


void TrackSpec_TrackEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TrackSpec_TrackEntry*>(&to_msg);
  auto& from = static_cast<const TrackSpec_TrackEntry&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackSpec.TrackEntry)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_width() != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  if (from._internal_ttype() != 0) {
    _this->_internal_set_ttype(from._internal_ttype());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackSpec_TrackEntry::CopyFrom(const TrackSpec_TrackEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackSpec.TrackEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackSpec_TrackEntry::IsInitialized() const {
  return true;
}

void TrackSpec_TrackEntry::InternalSwap(TrackSpec_TrackEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackSpec_TrackEntry, _impl_.ttype_)
      + sizeof(TrackSpec_TrackEntry::_impl_.ttype_)
      - PROTOBUF_FIELD_OFFSET(TrackSpec_TrackEntry, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackSpec_TrackEntry::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[20]);
}

// ===================================================================

class TrackSpec_Repeat::_Internal {
 public:
};

TrackSpec_Repeat::TrackSpec_Repeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackSpec.Repeat)
}
TrackSpec_Repeat::TrackSpec_Repeat(const TrackSpec_Repeat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TrackSpec_Repeat* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){from._impl_.entries_}
    , decltype(_impl_.nrep_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.nrep_ = from._impl_.nrep_;
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackSpec.Repeat)
}

inline void TrackSpec_Repeat::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.entries_){arena}
    , decltype(_impl_.nrep_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TrackSpec_Repeat::~TrackSpec_Repeat() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackSpec.Repeat)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrackSpec_Repeat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entries_.~RepeatedPtrField();
}

void TrackSpec_Repeat::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrackSpec_Repeat::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackSpec.Repeat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entries_.Clear();
  _impl_.nrep_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackSpec_Repeat::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vlsir.tetris.TrackSpec.TrackEntry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int64 nrep = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.nrep_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackSpec_Repeat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackSpec.Repeat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackSpec.TrackEntry entries = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int64 nrep = 2;
  if (this->_internal_nrep() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_nrep(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackSpec.Repeat)
  return target;
}

size_t TrackSpec_Repeat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackSpec.Repeat)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vlsir.tetris.TrackSpec.TrackEntry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->_impl_.entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int64 nrep = 2;
  if (this->_internal_nrep() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_nrep());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackSpec_Repeat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TrackSpec_Repeat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackSpec_Repeat::GetClassData() const { return &_class_data_; }


void TrackSpec_Repeat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TrackSpec_Repeat*>(&to_msg);
  auto& from = static_cast<const TrackSpec_Repeat&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackSpec.Repeat)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
  if (from._internal_nrep() != 0) {
    _this->_internal_set_nrep(from._internal_nrep());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackSpec_Repeat::CopyFrom(const TrackSpec_Repeat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackSpec.Repeat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackSpec_Repeat::IsInitialized() const {
  return true;
}

void TrackSpec_Repeat::InternalSwap(TrackSpec_Repeat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entries_.InternalSwap(&other->_impl_.entries_);
  swap(_impl_.nrep_, other->_impl_.nrep_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackSpec_Repeat::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[21]);
}

// ===================================================================

class TrackSpec::_Internal {
 public:
  static const ::vlsir::tetris::TrackSpec_TrackEntry& entry(const TrackSpec* msg);
  static const ::vlsir::tetris::TrackSpec_Repeat& repeat(const TrackSpec* msg);
};

const ::vlsir::tetris::TrackSpec_TrackEntry&
TrackSpec::_Internal::entry(const TrackSpec* msg) {
  return *msg->_impl_.spec_.entry_;
}
const ::vlsir::tetris::TrackSpec_Repeat&
TrackSpec::_Internal::repeat(const TrackSpec* msg) {
  return *msg->_impl_.spec_.repeat_;
}
void TrackSpec::set_allocated_entry(::vlsir::tetris::TrackSpec_TrackEntry* entry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_spec();
  if (entry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(entry);
    if (message_arena != submessage_arena) {
      entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, entry, submessage_arena);
    }
    set_has_entry();
    _impl_.spec_.entry_ = entry;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.TrackSpec.entry)
}
void TrackSpec::set_allocated_repeat(::vlsir::tetris::TrackSpec_Repeat* repeat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_spec();
  if (repeat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(repeat);
    if (message_arena != submessage_arena) {
      repeat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repeat, submessage_arena);
    }
    set_has_repeat();
    _impl_.spec_.repeat_ = repeat;
  }
  // @@protoc_insertion_point(field_set_allocated:vlsir.tetris.TrackSpec.repeat)
}
TrackSpec::TrackSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.TrackSpec)
}
TrackSpec::TrackSpec(const TrackSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TrackSpec* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.spec_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_spec();
  switch (from.spec_case()) {
    case kEntry: {
      _this->_internal_mutable_entry()->::vlsir::tetris::TrackSpec_TrackEntry::MergeFrom(
          from._internal_entry());
      break;
    }
    case kRepeat: {
      _this->_internal_mutable_repeat()->::vlsir::tetris::TrackSpec_Repeat::MergeFrom(
          from._internal_repeat());
      break;
    }
    case SPEC_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.TrackSpec)
}

inline void TrackSpec::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.spec_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_spec();
}

TrackSpec::~TrackSpec() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.TrackSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrackSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_spec()) {
    clear_spec();
  }
}

void TrackSpec::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrackSpec::clear_spec() {
// @@protoc_insertion_point(one_of_clear_start:vlsir.tetris.TrackSpec)
  switch (spec_case()) {
    case kEntry: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.spec_.entry_;
      }
      break;
    }
    case kRepeat: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.spec_.repeat_;
      }
      break;
    }
    case SPEC_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SPEC_NOT_SET;
}


void TrackSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.TrackSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_spec();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vlsir.tetris.TrackSpec.TrackEntry entry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_entry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vlsir.tetris.TrackSpec.Repeat repeat = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_repeat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.TrackSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vlsir.tetris.TrackSpec.TrackEntry entry = 1;
  if (_internal_has_entry()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::entry(this),
        _Internal::entry(this).GetCachedSize(), target, stream);
  }

  // .vlsir.tetris.TrackSpec.Repeat repeat = 2;
  if (_internal_has_repeat()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::repeat(this),
        _Internal::repeat(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.TrackSpec)
  return target;
}

size_t TrackSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.TrackSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (spec_case()) {
    // .vlsir.tetris.TrackSpec.TrackEntry entry = 1;
    case kEntry: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spec_.entry_);
      break;
    }
    // .vlsir.tetris.TrackSpec.Repeat repeat = 2;
    case kRepeat: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spec_.repeat_);
      break;
    }
    case SPEC_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TrackSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackSpec::GetClassData() const { return &_class_data_; }


void TrackSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TrackSpec*>(&to_msg);
  auto& from = static_cast<const TrackSpec&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.TrackSpec)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.spec_case()) {
    case kEntry: {
      _this->_internal_mutable_entry()->::vlsir::tetris::TrackSpec_TrackEntry::MergeFrom(
          from._internal_entry());
      break;
    }
    case kRepeat: {
      _this->_internal_mutable_repeat()->::vlsir::tetris::TrackSpec_Repeat::MergeFrom(
          from._internal_repeat());
      break;
    }
    case SPEC_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackSpec::CopyFrom(const TrackSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.TrackSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackSpec::IsInitialized() const {
  return true;
}

void TrackSpec::InternalSwap(TrackSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.spec_, other->_impl_.spec_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackSpec::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[22]);
}

// ===================================================================

class Xy::_Internal {
 public:
};

Xy::Xy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vlsir.tetris.Xy)
}
Xy::Xy(const Xy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Xy* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:vlsir.tetris.Xy)
}

inline void Xy::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){int64_t{0}}
    , decltype(_impl_.y_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Xy::~Xy() {
  // @@protoc_insertion_point(destructor:vlsir.tetris.Xy)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Xy::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Xy::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Xy::Clear() {
// @@protoc_insertion_point(message_clear_start:vlsir.tetris.Xy)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Xy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Xy::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vlsir.tetris.Xy)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 x = 1;
  if (this->_internal_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_x(), target);
  }

  // int64 y = 2;
  if (this->_internal_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vlsir.tetris.Xy)
  return target;
}

size_t Xy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vlsir.tetris.Xy)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 x = 1;
  if (this->_internal_x() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_x());
  }

  // int64 y = 2;
  if (this->_internal_y() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_y());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Xy::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Xy::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Xy::GetClassData() const { return &_class_data_; }


void Xy::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Xy*>(&to_msg);
  auto& from = static_cast<const Xy&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vlsir.tetris.Xy)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_x() != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  if (from._internal_y() != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Xy::CopyFrom(const Xy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vlsir.tetris.Xy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Xy::IsInitialized() const {
  return true;
}

void Xy::InternalSwap(Xy* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Xy, _impl_.y_)
      + sizeof(Xy::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(Xy, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Xy::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_layout_2ftetris_2eproto_getter, &descriptor_table_layout_2ftetris_2eproto_once,
      file_level_metadata_layout_2ftetris_2eproto[23]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace tetris
}  // namespace vlsir
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Library*
Arena::CreateMaybeMessage< ::vlsir::tetris::Library >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Library >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Cell*
Arena::CreateMaybeMessage< ::vlsir::tetris::Cell >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Cell >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Layout*
Arena::CreateMaybeMessage< ::vlsir::tetris::Layout >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Layout >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Assign*
Arena::CreateMaybeMessage< ::vlsir::tetris::Assign >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Assign >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackCross*
Arena::CreateMaybeMessage< ::vlsir::tetris::TrackCross >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackCross >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackRef*
Arena::CreateMaybeMessage< ::vlsir::tetris::TrackRef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackRef >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Outline*
Arena::CreateMaybeMessage< ::vlsir::tetris::Outline >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Outline >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Abstract*
Arena::CreateMaybeMessage< ::vlsir::tetris::Abstract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Abstract >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::AbstractPort_EdgePort*
Arena::CreateMaybeMessage< ::vlsir::tetris::AbstractPort_EdgePort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::AbstractPort_EdgePort >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::AbstractPort_ZTopEdgePort*
Arena::CreateMaybeMessage< ::vlsir::tetris::AbstractPort_ZTopEdgePort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::AbstractPort_ZTopEdgePort >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::AbstractPort_ZTopInner*
Arena::CreateMaybeMessage< ::vlsir::tetris::AbstractPort_ZTopInner >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::AbstractPort_ZTopInner >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::AbstractPort*
Arena::CreateMaybeMessage< ::vlsir::tetris::AbstractPort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::AbstractPort >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Instance*
Arena::CreateMaybeMessage< ::vlsir::tetris::Instance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Instance >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Place*
Arena::CreateMaybeMessage< ::vlsir::tetris::Place >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Place >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::RelPlace*
Arena::CreateMaybeMessage< ::vlsir::tetris::RelPlace >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::RelPlace >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Stack*
Arena::CreateMaybeMessage< ::vlsir::tetris::Stack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Stack >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::LayerEnum*
Arena::CreateMaybeMessage< ::vlsir::tetris::LayerEnum >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::LayerEnum >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::MetalLayer*
Arena::CreateMaybeMessage< ::vlsir::tetris::MetalLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::MetalLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::ViaLayer*
Arena::CreateMaybeMessage< ::vlsir::tetris::ViaLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::ViaLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::PrimitiveLayer*
Arena::CreateMaybeMessage< ::vlsir::tetris::PrimitiveLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::PrimitiveLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackSpec_TrackEntry*
Arena::CreateMaybeMessage< ::vlsir::tetris::TrackSpec_TrackEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackSpec_TrackEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackSpec_Repeat*
Arena::CreateMaybeMessage< ::vlsir::tetris::TrackSpec_Repeat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackSpec_Repeat >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::TrackSpec*
Arena::CreateMaybeMessage< ::vlsir::tetris::TrackSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::TrackSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::vlsir::tetris::Xy*
Arena::CreateMaybeMessage< ::vlsir::tetris::Xy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vlsir::tetris::Xy >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
